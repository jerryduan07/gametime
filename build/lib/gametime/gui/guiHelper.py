#!/usr/bin/env python

"""Exposes classes and functions that maintain the support classes for
the graphical user interface for GameTime.
"""

"""See the LICENSE file, located in the root directory of
the source distribution and
at http://verifun.eecs.berkeley.edu/gametime/about/LICENSE,
for details on the GameTime license and authors.
"""


import bz2
import os
import pickle

from PySide import QtGui
from PySide import QtCore
from PySide.QtCore import Qt

import gametime.pulpHelper as pulpHelper
from gametime import GameTime
from gametime import GameTimeError
from gametime import PathType
from gametime.defaults import config
from gametime.projectConfiguration import getFilePaths
from gametime.projectConfiguration import getFuncNames
from gametime.projectConfiguration import ProjectConfiguration
from gametime.histogram import writeHistogramToFile

# tempStartLabel = "TEMPSTART"
# tempEndLabel = "TEMPEND"


class Window(object):
    """ Position of window to display information. """
    # No view.
    NONE = 0
    # Left window.
    LEFT = -1
    # Right window.
    RIGHT = 1


class FileItem(object):
    def __init__(self, fileName, origLocation, data,
                 mainWin=None, assign=False):
        """A FileItem object is created for every file that has been opened
        by the user or that has been generated by the Analyzer. This object
        promotes easy file loading and line highlighting.
        """
        self.mainWindow = mainWin
        self.fileList = mainWin.fileSelectWidget.widget()
        self.basisValuesFile = None
        self.numBasisPaths = 0
        self.basisPaths = []
        self.worstPaths = []
        self.bestPaths = []
        self.randomPaths = []
        self.allPaths = []
        self.basisValues = []

        self.preprocessedFileItem = None

        #: True if an Analyzer object can be created for this file,
        #: False otherwise. A file cannot be analyzed and highlighted
        #: at the same time. The default value is True.
        self.canAnalyze = True

        #: Analyzer object associated with this file.
        self.analyzer = None

        self.highlightText = None
        #: Path object associated with this file.
        self.highlightPath = None

        #: Name of the file as displayed in the FileSelect list.
        self.originalName = origLocation
        self.displayName = fileName

        #: Current viewing mode.
        self.window = Window.NONE

        #: Order in which a FileItem is placed in a FileSelect list.
        self.displayIndex = None

        #: Maintains the name of the file being analyzed. This should
        #: never be changed after creating this FileItem instance.
        self.fileName = fileName

        #: Name of the file as displayed in the fileSelect list.
        self.origLocation = origLocation

        #: Text that should be displayed in the text viewing window.
        #: This will not contain the highlights.
        self.displayText = data

        self.assign = assign
        # """
        # Add line numbers to the display text
        # if the display text is not assignments
        # """
        # if not assign:
            # lines = self.displayText.split("\n")
            # for i in range(len(lines)):
                # lines[i]=str(i)+": "+lines[i]
            # self.displayText = "\n".join(lines)

        #: None if this FileItem contains the original file;
        #: otherwise, the FileItem that this is a path through.
        self.parentFile = None

        #: List of the FileItem objects that contain paths through
        #: this FileItem object.
        self.children = []

        self.startLine = ""
        self.startFile = ""
        self.endLine = ""
        self.endFile = ""

    def addToMainWindow(self):
        """
        Add this object to the dictionary of FileItem objects stored
        in the main window.
        """
        self.mainWindow.openItems[self.displayName] = self

    def setAnalyze(self, analyzeBool):
        """Sets the ``canAnalyze`` flag, which determines if a file
        can be analyzed.

        Arguments:
            analyzeBool:
                New truth value for the ``canAnalyze`` flag.
        """
        self.canAnalyze = analyzeBool

    def makeAnalyzer(self):
        """Make the ``Analyzer`` object that corresponds to the file
        currently being displayed, if possible.
        """
        self.analyzer = GameTime.analyze(self.projectConfig)

    def setHighlightPath(self, highlightPath):
        self.highlightPath = highlightPath

    def getHighlightPath(self):
        return self.highlightPath

    def setPreprocessedFileItem(self, fileItem):
        self.preprocessedFileItem = fileItem

    def getAnalyzeItem(self):
        analyzeItem = self
        while not analyzeItem or not analyzeItem.canAnalyze:
            analyzeItem = analyzeItem.getParent()
        return analyzeItem

    def importBasisValues(self, fileName, values):
        """Imports basis values from a file."""
        self.basisValuesFile = fileName
        self.basisValues = values
        for i in range(len(self.basisPaths)):
            path = self.basisPaths[i]
            lines = path.displayText.split("\n")
            valIndex = lines.index("Value:")+1
            lines[valIndex] = str(values[i])
            path.displayText = "\n".join(lines)

    def appendToFileSelect(self):
        """
        Appends the display name of the current file to the end of the fileList.
        """
        if self.parentFile == None:
            self.fileList.addItem(self.displayName)
            self.displayIndex = self.fileList.count() - 1
        else:
            #Note: This is called after adding the child to the parentFile, so
            #    if the parent is at index 0, the first child will be at 1.
            self.displayIndex = self.parentFile.displayIndex + \
                self.parentFile.getChildren().index(self)+1
            self.fileList.insertItem(self.displayIndex, self.displayName)

    def setAsLeftView(self):
        """Associates this FileItem instance with the left display window."""
        self.window = Window.LEFT
        # self.fileList.replaceItem(self.origLocation, self.displayIndex)
        self.mainWindow.leftTextEdit.setItem(self)

    def setAsRightView(self):
        """Associates this FileItem instance with the right display window."""
        self.window = Window.RIGHT
        # self.fileList.replaceItem(self.origLocation, self.displayIndex)
        self.mainWindow.rightTextEdit.setItem(self)

    def removeFromView(self):
        """
        Removes this FileItem instance from either the left or the right
        display window. Sets display name back to normal.
        """
        if self.window == Window.RIGHT:
            self.mainWindow.rightTextEdit.setItem(None)
        else:
            self.mainWindow.leftTextEdit.setItem(None)
        self.window = Window.NONE

    def getHighlightText(self):
        # Still looking for a better way to do this function.
        """Make the highlightText from the displayText.
        What this function does right now is reopen the original (non-Path())
        file, read each line, and check to see if it is a highlightable
        line. If it is, add the appropriate HTML tag (i.e. highlight the line).
        Then add the line to the highlightText.

        The bug here is that the current file may not have the same data as
        the original file. TODO(lisa): Still working on a way to do this.
        """
        def sanitize(text):
            text = text.replace("&", "&amp;")
            return text.replace(
                "<",
                "&lt;"
            ).replace(
                ">",
                "&gt;"
            ).replace(
                "\"",
                "&quot;"
            ).replace(
                "'",
                "&apos;"
            )

        if not self.highlightText:
            pathLineNumbers = self.highlightPath.lineNumbers

            self.highlightText = "<pre>"
            with open(self.origLocation, "r") as origFileHandler:
                origFileLines = origFileHandler.readlines()
                for lineNum, line in enumerate(origFileLines):
                    self.highlightText += (
                        "%s%s%s" %
                        (("<span style='background-color: #8DB6CD'>"
                          if lineNum + 1 in pathLineNumbers else ""),
                         sanitize(line),
                         ("</span>" if lineNum + 1 in pathLineNumbers else ""))
                    )
            self.highlightText = "%s</pre>" % self.highlightText
        return self.highlightText

    def getFileSelectIndex(self):
        """Get the index of this FileItem instance in the fileList."""
        return self.displayIndex

    def getFileName(self):
        """
        Get the (unchanged by display) fileName of this FileItem instance.

        @retval (unchanged by display) fileName of this FileItem instance.
        """
        return self.fileName

    def getDisplayText(self):
        """Get the (unchanged by highlighting) display text."""
        path = self.highlightPath
        if path:
            self.displayText = ("Assignments:\n%s\n\nPredicted Value:\n%s\n\n"
                                "Measured Value:\n%s" %
                                (path.getAssignments(),
                                 path.getPredictedValue(),
                                 path.getMeasuredValue()))
        return self.displayText

    def getChildren(self):
        """Get the children of this FileItem."""
        return self.children

    def addChild(self, newChild):
        """Add a child FileItem."""
        self.children.append(newChild)

    def removeChild(self, child):
        """Remove a child FileItem."""
        self.children.remove(child)
        if child in self.basisPaths:
            self.basisPaths.remove(child)
        elif child in self.worstPaths:
            self.worstPaths.remove(child)
        elif child in self.bestPaths:
            self.bestPaths.remove(child)
        elif child in self.randomPaths:
            self.randomPaths.remove(child)
        elif child in self.allPaths:
            self.allPaths.remove(child)

        if child.origLocation == " (Preprocessed)":
            self.preprocessedFileItem = None

    def setParent(self, sourceFileItem):
        """Set the parent of this FileItem."""
        oldName = self.displayName
        if self.assign:
            self.parentFile = sourceFileItem
            self.parentFile.addChild(self)
        else:
            self.displayName = "- %s" % self.displayName
        self.displayName = "%s %s" % (sourceFileItem.displayName,
                                      self.displayName)
        if oldName in self.mainWindow.openItems:
            self.mainWindow.openItems[self.displayName] = self
            self.mainWindow.openItems.pop(oldName)

    def getParent(self):
        """Get the parent of this FileItem."""
        return self.parentFile

    def getBasisPaths(self):
        """Return the basis paths stored for this FileItem."""
        return self.basisPaths

    def getWorstPaths(self):
        return self.worstPaths

    def getBestPaths(self):
        """Return the best paths stored for this FileItem."""
        return self.bestPaths

    def setProjectConfig(self, projectConfig):
        self.projectConfig = projectConfig


class FileSelectList(QtGui.QListWidget):
    """
    A FileSelectList is the list widget associated with the list of fileNames
    located to the left of the main text displays. This class provides
    operations to maintain the list.
    """
    def __init__(self, mainWin):
        super(FileSelectList, self).__init__()
        self.mainWindow = mainWin
        self.addItem("No files currently loaded.")
        self.activeLeft = self.activeRight = None

        # Double-clicking an item loads its contents in the main display.
        self.itemDoubleClicked.connect(self.loadFileToDisplay)

    def keyPressEvent(self, event):
        # Pressing the Return key, the Enter key (from the keypad) or
        # the spacebar on an item loads its contents in the main display.
        keyPressed = event.key()
        if keyPressed in [Qt.Key_Return, Qt.Key_Enter, Qt.Key_Space]:
            self.loadFileToDisplay(self.currentItem())
        elif keyPressed == Qt.Key_Up:
            self.setCurrentRow(max(0, self.currentRow() - 1))
        elif keyPressed == Qt.Key_Down:
            self.setCurrentRow(min(self.currentRow() + 1, self.count() - 1))

    def addFileName(self, fileItemToAdd, window):
        """
        Add or change a fileName in this fileSelect instance. If the FileItem
        has not been added to the fileSelect yet, call appendToFileSelect.
        Otherwise, the position of the FileItem's fileName should not change
        in the list. Either way, the FileItem's display text will be brought
        to the main text displays via the viewMode (options described below).

        @param fileItemToAdd {FileItem} even if it exists already
        @param viewMode {int} 0: no prefix; -1: left display, 1: right display
        @retval {bool} True if there is a display change, False if the FileItem
        was already displayed
        """
        if fileItemToAdd in [self.activeLeft, self.activeRight]:
            return False

        # If nothing has been added yet, clear default text.
        # TODO(jkotker): What if you open multiple files?
        if not self.activeLeft:
            self.takeItem(0)

        if fileItemToAdd.getFileSelectIndex() is None:
            fileItemToAdd.appendToFileSelect()

        #newDisplayValue = None
        if window is Window.LEFT:
            # if self.activeLeft:
            #     self.activeLeft.removeFromView()
            fileItemToAdd.setAsLeftView()
            if self.activeRight is not None and \
                    self.activeRight.getParent() != fileItemToAdd:
                self.activeRight.removeFromView()
                self.activeRight = None
            self.activeLeft = fileItemToAdd
            # newDisplayValue = False
        else:
            return True

    def loadFileToDisplay(self, item):
        """Slot called when a double-click signal has been triggered o
        on an item. If the item selected is already displayed, print
        a simple note to the status bar.
        """
        displayText = str(item.text())
        fileItemClicked = self.mainWindow.openItems.get(displayText, None)
        if fileItemClicked:
            if "+" not in fileItemClicked.displayName:
                fileItemClicked.setAsLeftView()
                self.activeLeft = fileItemClicked
                if self.activeRight is not None:
                    self.activeRight.removeFromView()
                    self.activeRight = None
            else:
                fileItemClicked.setAsRightView()
                self.activeRight = fileItemClicked
                self.mainWindow.slotShowHighlights()
            self.mainWindow.printToConsole("Loaded %s." % displayText)

    def removeItem(self, item):
        """Removes an item in the FileSelectList."""
        self.takeItem(item.displayIndex)
        for i in range(item.displayIndex, self.count()):
            itemName = str(self.item(i).text())
            itemName = itemName     # Keep pyflakes happy.
            self.mainWindow.openItems[itemName].displayIndex -= 1

    def insertItem(self, index, item):
        for i in range(index, self.count()):
            itemName = str(self.item(i).text())
            itemName = itemName     # Keep pyflakes happy.
            self.mainWindow.openItems[itemName].displayIndex += 1
        QtGui.QListWidget.insertItem(self, index, item)

    def removeGroup(self, parent):
        #Have to update indices of later items
        #Some other problem as well...
        grandParent = parent.getParent()
        if grandParent:
            return self.removeGroup(grandParent)
        numToRemove = len(parent.getChildren())+1
        startIndex = parent.displayIndex
        for i in range(startIndex, startIndex+numToRemove):
            item = self.takeItem(startIndex)
            self.mainWindow.openItems.pop(str(item.text()))
        for i in range(startIndex, self.count()):
            itemName = str(self.item(i).text())
            itemName = itemName     # Keep pyflakes happy.
            self.mainWindow.openItems[itemName].displayIndex -= numToRemove
        if self.count() == 0:
            self.addItem("No files currently loaded")
            self.mainWindow.leftTextEdit.setItem(None)
            self.mainWindow.rightTextEdit.setItem(None)
            self.activeLeft = self.activeRight = None
        elif startIndex == self.count():
            # Load the previous index to view.
            self.loadFileToDisplay(self.item(startIndex-1))
        else:
            self.loadFileToDisplay(self.item(startIndex))

    def wheelEvent(self, event):
        modifiers = QtGui.QApplication.keyboardModifiers()
        if modifiers == Qt.ControlModifier:
            mFont = self.font()
            if event.delta() > 0:
                diff = 2
            else:
                diff = -2
            if mFont.pointSize()+diff <= 0:
                return
            mFont.setPointSize(mFont.pointSize()+diff)
            self.setFont(mFont)
        else:
            super(FileSelectList, self).wheelEvent(event)


class TextEditObject(QtGui.QTextEdit):
    def __init__(self, args):
        """
        A TextEditObject instance is one of the two main text displays of
        the main window. In general, it has an associated FileItem instance,
        and it displays the displayText of that FileItem. However, if
        displayHighlights is called, it will display the highlightText of
        the instance, if available.
        """
        super(TextEditObject, self).__init__(args)

        self.setReadOnly(True)
        self.setWindowTitle("No file loaded.")

        self.analyzer = None
        self.fileItemObject = None

        self.setFont(QtGui.QFont("Courier", 10))
        self.setTextCursor(QtGui.QTextCursor())
        self.setTextInteractionFlags(Qt.TextSelectableByMouse |
                                     Qt.TextSelectableByKeyboard)

    def setMainWindow(self, mainWin):
        self.mainWindow = mainWin

    def mousePressEvent(self, e):
        """
        When the mouse is clicked somewhere inside this TextEditObject instance,
        the statusBar of the main window will display the windowTitle
        of the TextEditObject instance, which will be the fileName of the
        associated FileItem object.
        """
        self.mainWindow.statusBar().showMessage(self.windowTitle())

    def setItem(self, fileItemToSet):
        """Change FileItem instances and set displayText to new instance.
        Also change windowTitle.
        """
        if fileItemToSet is None:
            self.fileItemObject = None
            self.setText("")
            self.setWindowTitle("No file loaded.")
        else:
            self.fileItemObject = fileItemToSet
            self.setText(fileItemToSet.getDisplayText())
            self.setWindowTitle(self.fileItemObject.getFileName())

    def displayHighlights(self):
        """
        Try accessing the highlightText of the fileItemObject instance, if it
        exists. If it exists, set highlightText as display text. Otherwise,
        do nothing but print out a console message.
        """
        if not self.fileItemObject:
            msg = "No path has been selected to be highlighted."
            self.mainWindow.printToConsole(msg)
        else:
            openFileItems = self.mainWindow.openItems.get(
                self.fileItemObject.getParent().displayName,
                None
            )
            if openFileItems:
                self.mainWindow.addToWindow(openFileItems, Window.LEFT)
                if self.mainWindow.highlightsEnabled:
                    self.mainWindow.leftTextEdit.setHtml(
                        self.fileItemObject.getHighlightText()
                    )
                else:
                    parentFile = self.fileItemObject.parentFile
                    self.mainWindow.leftTextEdit.setText(
                        parentFile.preprocessedFileItem.displayText
                    )

    def clear(self):
        self.setText("")
        self.setWindowTitle("No file loaded.")
        self.analyzer = None
        self.fileItemObject = None


class GenericDialog(QtGui.QDialog):
    """Covers all dialogs that pop up when the user wants to generate feasible
    paths for a particular file.
    The title is displayed according to the enumCommand supplied. In the dialog
    itself, the user must choose between two options: left or right display.
    The dialog returns True if the left is chosen, and False otherwise.

    Small sidenote: exec_() disables access to all other windows once this
    dialog is created until it is destroyed. When it is destroyed, exec_()
    returns the value of done(), which signals the end of a dialog.
    """
    def __init__(self, enumCommand, caller, showfileNamesFlag,
                 fileItemToDisplay=None):
        """
        @param enumCommand {int} Depending on the integer supplied, the title
            of the dialog will vary.
        @param caller {Object} The caller of this class.
        @param showfileNamesFlag {bool} If True, show fileNames next to radio
            buttons. If False, do not show fileNames.
        @param fileItemToDisplay {FileItem} If available, display the FileItem.
        """
        QtGui.QDialog.__init__(self)

        self.caller = caller
        self.resize(508, 300)
        self.layout = QtGui.QVBoxLayout(self)

        # Set title of dialog.
        title = "Default Choice Dialog"
        if enumCommand == 0:
            title = "Generate basis paths."
        elif enumCommand == 1:
            title = "Generate worst-case feasible paths."
        elif enumCommand == 2:
            title = "Generate best-case feasible paths."
        elif enumCommand == 3:
            title = "Highlight line numbers for analyzed file."
        elif enumCommand == 4:
            title = "Select display to save."
        self.taskTitleLabel = QtGui.QLabel(title, self)
        self.layout.addWidget(self.taskTitleLabel)

        if fileItemToDisplay:
            # Show fileName of FileItem to display.
            fileName = "File selected: %s" % fileItemToDisplay.getFileName()
            self.layout.addWidget(QtGui.QLabel(fileName, self))

        # Create radio buttons so that the user can only select either left
        # or right (no other choices). The window title of each display is
        # given only if the showfileNamesFlag is on.
        selectView = QtGui.QGroupBox("Which file?", self)
        vboxFileSelect = QtGui.QVBoxLayout(selectView)
        self.leftView = QtGui.QRadioButton("Left")
        self.rightView = QtGui.QRadioButton("Right")
        if showfileNamesFlag:
            self.leftView.setText(
                "Left: %s" %
                caller.mainWindow.leftTextEdit.windowTitle()
            )
            self.rightView.setText(
                "Right: %s" %
                caller.mainWindow.rightTextEdit.windowTitle()
            )
        self.leftView.setChecked(1)
        vboxFileSelect.addWidget(self.leftView)
        vboxFileSelect.addWidget(self.rightView)
        vboxFileSelect.addStretch()
        self.layout.addWidget(selectView)

        # OK/Cancel buttons. "OK" is linked to the on_accept slot when
        # pressed, and Cancel to the on_reject slot.
        buttonBox = QtGui.QDialogButtonBox(Qt.Horizontal, self)
        buttonBox.setStandardButtons(
            QtGui.QDialogButtonBox.Cancel |
            QtGui.QDialogButtonBox.Ok
        )
        buttonBox.accepted.connect(self.on_accept)
        buttonBox.rejected.connect(self.on_reject)

        self.layout.addWidget(buttonBox)

    def leftViewChecked(self):
        """After execution, will be set to the result of
        the radio selection.
        """
        return self.leftView.isChecked()

    def on_accept(self):
        """If OK is pressed, return a True/False as described above."""
        self.accept()

    def on_reject(self):
        """If cancel is pressed, print to Console that no file was selected."""
        self.mainWindow.printToConsole("No file selected.")
        self.reject()


class NumPathsDialog(QtGui.QDialog):
    # If the parameter `requireOvercompleteBasis` is True then the dialog
    # does not give the user a choice to choose OB_EXTRACTION flag, but sets
    # it the flag to True by default
    def __init__(self, caller, winType, requireOvercompleteBasis=False):
        QtGui.QDialog.__init__(self)
        self.caller = caller
        self.caller.useObExtraction = requireOvercompleteBasis
        self.numPathsEdit = QtGui.QLineEdit()
        self.numPathsEdit.setText(str(self.caller.numPaths))
        # Row at which to show the OK / Cancel buttonw
        standardRow = 2
        self.setWindowTitle("Number of paths")
        layout = QtGui.QGridLayout()
        layout.setSpacing(5)
        layout.addWidget(self.numPathsEdit, 1, 0)
        if winType == "Worst":
            numPathsTitle = QtGui.QLabel("How many worst-case feasible paths "
                                         "would you like to generate?")
        elif winType == "Best":
            numPathsTitle = QtGui.QLabel("How many best-case feasible paths "
                                         "would you like to generate?")
        elif winType == "Random":
            numPathsTitle = QtGui.QLabel("How many random feasible paths "
                                         "would you like to generate?")

        if winType == "Worst" or winType == "Best":
            if (requireOvercompleteBasis):
                layout.addWidget(QtGui.QLabel(
                  "Overcomplete basis generated, using overcomplete-basis "
                  "extraction"))
            else:
              self.newExtraction = \
                  QtGui.QCheckBox("Use Overcomplete-Basis Extraction")
              layout.addWidget(self.newExtraction, 2, 0)
            # If interested in the longest path, offer both path extraction
            # algorithms and move standard buttons one row lower
            standardRow = 3
            
        layout.addWidget(numPathsTitle, 0, 0, 1, 3)

        fileSelectWidget = caller.mainWindow.fileSelectWidget
        currentFile = fileSelectWidget.widget().activeLeft.getAnalyzeItem()
        if currentFile.analyzer is not None:
            maxPaths = QtGui.QLabel("Maximum of %i" %
                                    currentFile.analyzer.dag.numPaths)
            layout.addWidget(maxPaths, 1, 1)
        self.layout = layout
        self.setLayout(self.layout)

        #Add standard buttons here at the bottom
        okButton = QtGui.QPushButton("OK")
        cancelButton = QtGui.QPushButton("Cancel")
        self.layout.addWidget(okButton, standardRow, 1)
        self.layout.addWidget(cancelButton, standardRow, 2)
        okButton.clicked.connect(self.on_accept)
        cancelButton.clicked.connect(self.on_reject)

        self.show()

    def on_accept(self):
        try:
            self.caller.numPaths = int(str(self.numPathsEdit.text()))
            if (hasattr(self, 'newExtraction')):
                self.caller.useObExtraction = self.newExtraction.isChecked()
        except ValueError:
            self.caller.mainWindow.printToConsole("Please enter a valid "
                                                  "integer value.")
            return
        self.accept()

    def on_reject(self):
        self.caller.mainWindow.printToConsole("Generation of worst "
                                              "cases cancelled.")
        self.reject()

class AllPathsDialog(QtGui.QDialog):
    # If the parameter `requireOvercompleteBasis` is True then the dialog
    # does not give the user a choice to choose OB_EXTRACTION flag, but sets
    # it the flag to True by default
    def __init__(self, caller, requireOvercompleteBasis=False):
        QtGui.QDialog.__init__(self)
        self.caller = caller
        self.caller.useObExtraction = requireOvercompleteBasis
        self.setWindowTitle("Generating all feasible paths")
        layout = QtGui.QGridLayout()
        layout.setSpacing(5)
        fileSelectWidget = caller.mainWindow.fileSelectWidget
        currentFile = fileSelectWidget.widget().activeLeft.getAnalyzeItem()
        layout.addWidget(QtGui.QLabel("WARNING: This may take a long time, as "
                                      "there are %i possible paths that can be "
                                      "generated.\n Are you sure you wish to "
                                      "continue?" 
                                      % currentFile.analyzer.dag.numPaths),
                         0, 0)
        if (requireOvercompleteBasis):
            layout.addWidget(QtGui.QLabel(
              "Overcomplete basis generated, using overcomplete-basis "
              "extraction"))
        else:
            self.newExtraction = \
                QtGui.QCheckBox("Use Overcomplete-Basis Extraction")
            layout.addWidget(self.newExtraction)

        self.layout = layout
        self.setLayout(self.layout)

        #Add standard buttons here at the bottom
        okButton = QtGui.QPushButton("OK")
        cancelButton = QtGui.QPushButton("Cancel")
        self.layout.addWidget(okButton, 2, 1)
        self.layout.addWidget(cancelButton, 2, 2)
        okButton.clicked.connect(self.on_accept)
        cancelButton.clicked.connect(self.on_reject)

        self.show()

    def on_accept(self):
        try:
            if (hasattr(self, 'newExtraction')):
                self.caller.useObExtraction = self.newExtraction.isChecked()
        except ValueError:
            return
        self.accept()

    def on_reject(self):
        self.caller.mainWindow.printToConsole(
            "Generation of all feasible paths cancelled.")
        self.reject()


class HistogramDialog(QtGui.QDialog):
    def __init__(self, caller):
        QtGui.QDialog.__init__(self)
        self.mainWindow = caller
        self.setWindowTitle("Generate Histogram")

        layout = QtGui.QGridLayout()
        layout.setSpacing(5)
        self.shouldChangeLowerBound = True
        self.shouldChangeUpperBound = True

        #bin size (label: text edit)
        #lower bound (label: text edit)
        #upper bound (label: text edit)
        #paths to use (label: dropdown)
        numBinsTitle = QtGui.QLabel("Number of bins")
        self.numBinsEdit = QtGui.QLineEdit()
        layout.addWidget(numBinsTitle, 0, 0)
        layout.addWidget(self.numBinsEdit, 0, 1)
        self.numBinsEdit.setFixedWidth(50)

        lowerBoundTitle = QtGui.QLabel("Lower bound")
        self.lowerBoundEdit = QtGui.QLineEdit()
        layout.addWidget(lowerBoundTitle, 1, 0)
        layout.addWidget(self.lowerBoundEdit, 1, 1)
        self.lowerBoundEdit.setFixedWidth(50)
        QtCore.QObject.connect(self.lowerBoundEdit,
                               QtCore.SIGNAL("textChanged(QString)"),
                               self.lowerBoundChanged)

        upperBoundTitle = QtGui.QLabel("Upper bound")
        self.upperBoundEdit = QtGui.QLineEdit()
        layout.addWidget(upperBoundTitle, 1, 2)
        layout.addWidget(self.upperBoundEdit, 1, 3)
        self.upperBoundEdit.setFixedWidth(50)
        QtCore.QObject.connect(self.upperBoundEdit,
                               QtCore.SIGNAL("textChanged(QString)"),
                               self.upperBoundChanged)

        saveLocationTitle = QtGui.QLabel("Save location")
        self.saveLocationEdit = QtGui.QLineEdit()
        layout.addWidget(saveLocationTitle, 3, 0)
        layout.addWidget(self.saveLocationEdit, 3, 1, 1, 2)

        browseButton = QtGui.QPushButton("Browse...")
        layout.addWidget(browseButton, 3, 3)
        browseButton.clicked.connect(self.browseFile)

        pathTitle = QtGui.QLabel("Paths to use")
        self.pathEdit = QtGui.QComboBox()
        self.pathItems = self.getPathNamesAndItems()
        for i, name in enumerate(self.pathItems.keys()):
            self.pathEdit.insertItem(i, name)
        QtCore.QObject.connect(self.pathEdit,
                               QtCore.SIGNAL("currentIndexChanged(QString)"),
                               self.changeBounds)
        layout.addWidget(pathTitle, 4, 0)
        layout.addWidget(self.pathEdit, 4, 1, 1, 3)

        valueText1 = QtGui.QLabel("Use")
        self.valueType = QtGui.QComboBox()
        self.valueType.insertItem(0, "measured")
        self.valueType.insertItem(1, "predicted")
        QtCore.QObject.connect(self.valueType,
                               QtCore.SIGNAL("currentIndexChanged(QString)"),
                               self.changeBounds)
        valueText2 = QtGui.QLabel("values.")

        layout.addWidget(valueText1, 5, 0)
        layout.addWidget(self.valueType, 5, 1, 1, 2)
        layout.addWidget(valueText2, 5, 3)

        self.layout = layout
        self.setLayout(self.layout)

        #Add standard buttons here at the bottom
        okButton = QtGui.QPushButton("OK")
        cancelButton = QtGui.QPushButton("Cancel")
        self.layout.addWidget(okButton, 6, 2)
        self.layout.addWidget(cancelButton, 6, 3)
        okButton.clicked.connect(self.on_accept)
        cancelButton.clicked.connect(self.on_reject)

        self.changeBounds(None)
        self.show()

    def lowerBoundChanged(self, _):
        self.shouldChangeLowerBound = False

    def upperBoundChanged(self, _):
        self.shouldChangeUpperBound = False

    def changeBounds(self, _):
        if self.valueType.currentText() == "measured":
            measured = True
        else:
            measured = False

        pathItems = self.pathItems[str(self.pathEdit.currentText())]
        if measured:
            pathValues = [item.measuredValue for item in pathItems]
        else:
            pathValues = [item.predictedValue for item in pathItems]

        if self.shouldChangeLowerBound:
            self.lowerBoundEdit.setText(str(min(pathValues)))
            self.shouldChangeLowerBound = True
        if self.shouldChangeUpperBound:
            self.upperBoundEdit.setText(str(max(pathValues)))
            self.shouldChangeUpperBound = True

    def on_accept(self):
        try:
            errorMessage = "Invalid number of bins."
            numBins = int(str(self.numBinsEdit.text()))

            if self.valueType.currentText() == "measured":
                measured = True
            else:
                measured = False

            errorMessage = "Invalid paths chosen."
            pathItems = self.pathItems[str(self.pathEdit.currentText())]
            if measured:
                pathValues = [item.measuredValue for item in pathItems]
            else:
                pathValues = [item.predictedValue for item in pathItems]

            errorMessage = "Invalid lower bound."
            lowerString = str(self.lowerBoundEdit.text())
            if lowerString == "":
                lower = min(pathValues)
            else:
                lower = float(lowerString)

            errorMessage = "Invalid upper bound."
            upperString = str(self.upperBoundEdit.text())
            if upperString == "":
                upper = max(pathValues)
            else:
                upper = float(upperString)

            errorMessage = "Save location cannot be empty."
            histogramLocation = str(self.saveLocationEdit.text())
            if histogramLocation == "":
                raise Exception("Bad save location")

        except Exception:
            self.mainWindow.printToConsole(errorMessage)
            return

        if max(pathValues) > upper or min(pathValues) < lower:
            if ((not ConfirmationDialog(
                    "Some path values are outside of the specified range, and "
                    "will not be included in the histogram.\n"
                    "Are you sure you want to continue?"
                ))).exec_():
                return

        histogramRange = (lower, upper)
        writeHistogramToFile(histogramLocation,
                             pathItems,
                             numBins,
                             histogramRange,
                             measured)
        self.accept()

    def on_reject(self):
        self.mainWindow.printToConsole("Histogram generation canceled.")
        self.reject()

    def browseFile(self):
        fileDialog = QtGui.QFileDialog()
        fileName, _ = fileDialog.getSaveFileName(self, "Save File", ".")
        if not fileName:
            return
        self.saveLocationEdit.setText(fileName)

    def getPathNamesAndItems(self):
        openFileItems = self.mainWindow.openItems.values()
        pathNamesAndValues = {}
        for item in openFileItems:
            if len(item.children) > 0:
                if len(item.basisPaths) > 0:
                    pathTitle = ("%s: Basis paths (%d)" %
                                 (item.displayName, len(item.basisPaths)))
                    pathValues = [i.getHighlightPath() for i in item.basisPaths]
                    pathNamesAndValues[pathTitle] = pathValues
                if len(item.worstPaths) > 0:
                    pathTitle = ("%s: Worst-case paths (%d)" %
                                 (item.displayName, len(item.worstPaths)))
                    pathValues = [i.getHighlightPath() for i in item.worstPaths]
                    pathNamesAndValues[pathTitle] = pathValues
                if len(item.bestPaths) > 0:
                    pathTitle = ("%s: Best-case paths (%d)" %
                                 (item.displayName, len(item.bestPaths)))
                    pathValues = [i.getHighlightPath() for i in item.bestPaths]
                    pathNamesAndValues[pathTitle] = pathValues
                if len(item.randomPaths) > 0:
                    pathTitle = ("%s: Random paths (%d)" %
                                 (item.displayName, len(item.randomPaths)))
                    pathValues = [i.getHighlightPath() for i
                                  in item.randomPaths]
                    pathNamesAndValues[pathTitle] = pathValues
                if len(item.allPaths) > 0:
                    pathTitle = ("%s: All paths (%d)" %
                                 (item.displayName, len(item.allPaths)))
                    pathValues = [i.getHighlightPath() for i in item.allPaths]
                    pathNamesAndValues[pathTitle] = pathValues
        return pathNamesAndValues


class XmlFileDialog(QtGui.QDialog):
    def __init__(self, caller, projectConfig):
        super(XmlFileDialog, self).__init__()
        self.setWindowTitle("Project Configuration")
        self.mainWindow = caller
        # TODO: May change/make scrollable later.
        # self.resize(300, 500)
        self.layout = QtGui.QGridLayout(self)
        self.layout.setSpacing(5)

        textFieldNames = [
            "location",
            "analysis-function",
            "start-label",
            "end-label",
            "include",
            "merge",
            "inline",
            "ilp-solver",
            "smt-solver",
        ]
        textFieldNamesToTitles = {
            "location": "Location of C file",
            "analysis-function": "Function to analyze",
            "start-label": "Label to start analysis at",
            "end-label": "Label to end analysis at",
            "include": "Paths of directories to include",
            "merge": "Paths of files to merge",
            "inline": "Names of functions to inline",
            "ilp-solver": "ILP solver",
            "smt-solver": "SMT solver",
        }

        booleanFieldNames = []#["unroll-loops"]
        booleanFieldNamesToTitles = {
            # "detect-loops",
            # "unroll-loops": "Unroll loops in the code",
            # "draw-cfg",
            # "dump-instruction-trace",
            # "dump-ir",
            # "dump-path",
            # "dump-z3",
            # "keep-cil-temps"
        }

        self.textFields = textFields = {}
        self.booleanFields = booleanFields = {}

        self.projectConfig = projectConfig

        fieldVals = {
            "location": projectConfig.locationOrigFile,
            "analysis-function": projectConfig.func,
            "start-label": projectConfig.startLabel,
            "end-label": projectConfig.endLabel,
            "smt-solver": str(projectConfig.smtSolver),
            "ilp-solver": pulpHelper.getIlpSolverName(projectConfig.ilpSolver),
            "include": " ".join(projectConfig.included),
            "inline": " ".join(projectConfig.inlined),
            "unroll-loops":projectConfig.UNROLL_LOOPS
        }

        for textFieldNum, textFieldName in enumerate(textFieldNames):
            fieldTitle = QtGui.QLabel(textFieldNamesToTitles[textFieldName])
            valueText = fieldVals.get(textFieldName, "")

            if textFieldName == "smt-solver":
                fieldEdit = QtGui.QComboBox()

                entries = [
                    "z3",
                    "boolector",
                    "boolector-lingeling",
                    "boolector-minisat",
                    "boolector-picosat"
                ]

                for entryNum, entry in enumerate(entries):
                    fieldEdit.insertItem(entryNum, entry)
                    if valueText == entry:
                        fieldEdit.setCurrentIndex(entryNum)
            elif textFieldName == "ilp-solver":
                fieldEdit = QtGui.QComboBox()
                entries = [
                    "",
                    "cbc",
                    "cbc-pulp",
                    "cplex",
                    "glpk",
                    "gurobi",
                    "xpress"
                ]

                for entryNum, entry in enumerate(entries):
                    fieldEdit.insertItem(entryNum, entry)
                    if valueText == entry:
                        fieldEdit.setCurrentIndex(entryNum)
            else:
                fieldEdit = QtGui.QLineEdit(valueText)
            textFields[textFieldName] = fieldEdit

            self.layout.addWidget(fieldTitle, textFieldNum + 1, 0)
            self.layout.addWidget(fieldEdit, textFieldNum + 1, 1)
        numTextFields = len(textFieldNamesToTitles)

        for booleanFieldNum, booleanFieldName in enumerate(booleanFieldNames):
            fieldTitle = QtGui.QLabel(
                booleanFieldNamesToTitles[booleanFieldName]
            )

            fieldEdit = QtGui.QCheckBox()
            fieldEdit.setChecked(fieldVals.get(booleanFieldName, False))
            booleanFields[booleanFieldName] = fieldEdit

            self.layout.addWidget(
                fieldTitle,
                numTextFields + booleanFieldNum + 1,
                0
            )
            self.layout.addWidget(
                fieldEdit,
                numTextFields + booleanFieldNum + 1,
                1
            )
        numBooleanFields = len(booleanFieldNamesToTitles)

        # fieldTitle = QtGui.QLabel("Location of project configuration "
                                  # "XML file")
        # valueText = self.xmlLocation if isXmlFile else ""
        # self.xmlNameEdit = QtGui.QLineEdit(valueText)
        # self.layout.addWidget(
            # fieldTitle,
            # numTextFields + numBooleanFields + 1,
            # 0
        # )
        # self.layout.addWidget(
            # self.xmlNameEdit,
            # numTextFields + numBooleanFields + 1,
            # 1
        # )

        # browseButton = QtGui.QPushButton("Browse...")
        # self.layout.addWidget(
            # browseButton,
            # numTextFields + numBooleanFields + 2,
            # 1
        # )
        # browseButton.clicked.connect(self.browseFile)

        # OK/Cancel buttons. OK is linked to the on_accept slot when
        # pressed, and Cancel to the on_reject slot.
        buttonBox = QtGui.QDialogButtonBox(Qt.Horizontal, self)
        buttonBox.setStandardButtons(
            QtGui.QDialogButtonBox.Cancel | QtGui.QDialogButtonBox.Ok
        )
        buttonBox.accepted.connect(self.on_accept)
        buttonBox.rejected.connect(self.on_reject)

        self.layout.addWidget(
            buttonBox,
            numTextFields + numBooleanFields + 3,
            0
        )

    def browseFile(self):
        # DEPRECATED.
        baseDirectory = os.path.dirname(self.xmlLocation)
        fileName, _ = QtGui.QFileDialog.getSaveFileName(
            self,
            "Save File",
            baseDirectory
        )

        if not fileName:
            return
        self.xmlNameEdit.setText(fileName)

    def on_accept(self):
        textFields = self.textFields
        for textField in textFields:
            if textField in ["smt-solver", "ilp-solver"]:
                fieldVal = str(textFields[textField].currentText())
            else:
                fieldVal = str(textFields[textField].text())

            if textField == "location":
                locationFile = fieldVal
            elif textField == "analysis-function":
                func = fieldVal
            elif textField == "start-label":
                startLabel = fieldVal
            elif textField == "end-label":
                endLabel = fieldVal
            elif textField == "smt-solver":
                smtSolverName = fieldVal
            elif textField == "ilp-solver":
                ilpSolverName = fieldVal
            elif textField == "include":
                if fieldVal != "":
                    # TODO (jkotker): Be smarter about relative locations.
                    # projectConfigDir = \
                    # os.path.dirname(os.path.abspath(self.xmlLocation))
                    included = getFilePaths(fieldVal) # , projectConfigDir)
                else:
                    included = []
            elif textField == "inline":
                inlined = (getFuncNames(fieldVal) if fieldVal != "" else [])


        # booleanFields = self.booleanFields
        # for booleanField in booleanFields:
        #     fieldVal = booleanFields[booleanField].isChecked()
        #     if booleanField == "unroll-loops":
        #         unrollLoops = fieldVal

        self.projectConfig = ProjectConfiguration(
            locationFile=locationFile,
            func=func,
            smtSolverName=smtSolverName,
            startLabel=startLabel,
            endLabel=endLabel,
            included=included,
            inlined=inlined,
            # unrollLoops=unrollLoops,
            ilpSolverName=ilpSolverName
        )

        # self.fileName = str(self.xmlNameEdit.text())
        # if self.fileName == "":
            # self.mainWindow.printToConsole("Please provide a location "
                # "where this project will be saved.")
            # return
        # self.projectConfig.writeToXmlFile(self.fileName)

        self.accept()

    def on_reject(self):
        self.reject()


class LoopBoundsDialog(QtGui.QDialog):
    """Assumes that loops have been detected and
    the loop config file has been generated."""
    def __init__(self, caller):
        QtGui.QDialog.__init__(self)
        self.setWindowTitle("Loop Bounds")
        self.mainWindow = caller
        self.resize(300, 200)
        self.layout = QtGui.QGridLayout(self)
        self.layout.setSpacing(5)

        fileSelectWidget = self.mainWindow.fileSelectWidget
        self.currentFile = fileSelectWidget.widget().activeLeft.getAnalyzeItem()
        self.projectConfig = self.currentFile.projectConfig
        self.loopConfigFile = os.path.join(self.projectConfig.locationTempDir,
                                           config.TEMP_LOOP_CONFIG)

        #Do we want an import for this as well?
        boundDirective = "Fill in the loop bounds below"
        boundDirectiveLabel = QtGui.QLabel(boundDirective, self)
        self.layout.addWidget(boundDirectiveLabel, 0, 0)

        buttonBox = QtGui.QDialogButtonBox(Qt.Horizontal, self)
        buttonBox.setStandardButtons(
            QtGui.QDialogButtonBox.Cancel | QtGui.QDialogButtonBox.Ok
        )
        buttonBox.accepted.connect(self.on_accept)
        buttonBox.rejected.connect(self.on_reject)

        self.layout.addWidget(buttonBox, 1, 0)

        self.loopInfo = self.readLoopConfig()
        self.boundEdits = []


        for i, info in enumerate(self.loopInfo):
            # fileName, lineNumber, currentValue, loopHeader = info
            fileName, lineNumber, currentValue = info
            loopFile = QtGui.QLabel(fileName)
            lineLabel = QtGui.QLabel(lineNumber)
            boundEdit = QtGui.QLineEdit(str(currentValue))
            # headerLabel = QtGui.QLabel(loopHeader)
            self.boundEdits.append(boundEdit)
            self.layout.addWidget(loopFile, i+2, 0)
            self.layout.addWidget(lineLabel, i+2, 1)
            self.layout.addWidget(boundEdit, i+2, 2)
            # self.layout.addWidget(headerLabel, 2*i+3, 0)

    def on_accept(self):
        #Check that loop bounds have been filled in and write them to the file
        #then re-run the analyzer
        loopBounds = []
        try:
            for boundEdit in self.boundEdits:
                loopBounds.append(int(str(boundEdit.text())))
        except ValueError:
            self.mainWindow.printToConsole("Please input integer "
                                           "values only.")
            return

        self.setLoopBounds(loopBounds)

        if self.writeLoopConfig():
            self.projectConfig.UNROLL_LOOPS = True
            self.accept()
        else:
            self.mainWindow.printToConsole("There was a problem creating "
                                           "the loop configuration file.")

    def on_reject(self):
        self.reject()

    def setLoopBounds(self, newBounds):
        newLoopInfo = []
        for i, oldInfo in enumerate(self.loopInfo):
            newInfo = (oldInfo[0], oldInfo[1], newBounds[i])
            newLoopInfo.append(newInfo)
        self.loopInfo = newLoopInfo

    def readLoopConfig(self):
        # currentLoop = []
        loopInfo = []
        with open(self.loopConfigFile, "r") as loopConfigReader:
            for line in loopConfigReader:
        #        if line[0] == "#":
        #            currentLoop.append(line[1:])
        #        else:
                fileName, lineNumber, value = line.split(",")
                intValue = int(value)
                loopInfo.append((fileName, str(int(lineNumber)), intValue))
        return loopInfo


    def writeLoopConfig(self):
        loopOutput = ""
        for info in self.loopInfo:
           # fileName, lineNumber, currentValue, loopHeader = info
            loopOutput += ("%s,%s,%i\n"%tuple(info))
                           # "#%s\n" %tuple(info))
        try:
            with open(self.loopConfigFile, "w") as loopConfigWriter:
                loopConfigWriter.write(loopOutput)
        except Exception:
            return False
        return True


class BasisValuesDialog(QtGui.QDialog):
    """
        @param caller {Object} The caller of this class.
    """
    def __init__(self, caller):
        QtGui.QDialog.__init__(self)
        self.setWindowTitle("Basis Values")
        self.mainWindow = caller
        self.resize(300, 200)
        self.layout = QtGui.QGridLayout(self)
        self.layout.setSpacing(5)

        fileSelectWidget = self.mainWindow.fileSelectWidget
        self.currentFile = fileSelectWidget.widget().activeLeft.getAnalyzeItem()

        # Set title of dialog.
        # title = "Basis Values"
        # self.taskTitleLabel = QtGui.QLabel(title, self)
        # self.layout.addWidget(self.taskTitleLabel, 0, 1)

        importDirective = "Fill in the basis values below, or"
        importDirectiveLabel = QtGui.QLabel(importDirective, self)
        self.layout.addWidget(importDirectiveLabel, 0, 0)

        importPathsButton = QtGui.QPushButton("Import from file...")
        importPathsButton.clicked.connect(self.importBasisDialog)
        self.layout.addWidget(importPathsButton, 0, 1)

        # OK/Cancel buttons. OK is linked to the on_accept slot when
        # pressed, and Cancel to the on_reject slot.
        buttonBox = QtGui.QDialogButtonBox(Qt.Horizontal, self)
        buttonBox.setStandardButtons(
            QtGui.QDialogButtonBox.Cancel | QtGui.QDialogButtonBox.Ok
        )
        buttonBox.accepted.connect(self.on_accept)
        buttonBox.rejected.connect(self.on_reject)

        self.layout.addWidget(buttonBox, 1, 0, 1, 2)

        # pathTitles = []
        self.pathEdits = []
        self.numPaths = self.currentFile.numBasisPaths
        if self.numPaths == 0:
            self.mainWindow.printToConsole(
                "You need to generate the basis paths first."
            )
            return
        for i in range(self.numPaths):
            pathTitle = QtGui.QLabel("Path %d" % (i+1))
            valueText = ""
            if self.currentFile.basisValues != []:
                valueText = str(self.currentFile.basisValues[i])
            pathEdit = QtGui.QLineEdit(valueText)
            self.pathEdits.append(pathEdit)
            self.layout.addWidget(pathTitle, i+2, 0)
            self.layout.addWidget(pathEdit, i+2, 1)

    def importBasisDialog(self):
        analyzer = self.currentFile.analyzer
        projectConfig = analyzer.projectConfig

        fileDialog = QtGui.QFileDialog()
        fileDialog.setFileMode(QtGui.QFileDialog.ExistingFile)
        valueFile, _ = fileDialog.getOpenFileName(
            self,
            "Open File",
            projectConfig.locationOrigDir
        )

        if not valueFile:
            self.mainWindow.printToConsole("No file selected.")
            return
        try:
            analyzer.loadBasisValuesFromFile(valueFile)
            basisPaths = analyzer.basisPaths
            for i, basisPath in enumerate(basisPaths):
                self.pathEdits[i].setText(unicode(basisPath.getMeasuredValue()))
        except GameTimeError:
            self.mainWindow.printToConsole("Basis values file is not "
                                           "properly formatted.")

    def on_accept(self):
        basisValues = []
        try:
            for value in self.pathEdits:
                basisValues.append(float(str(value.text())))
        except ValueError:
            self.mainWindow.printToConsole("Please input numerical "
                                           "values only.")
            return

        # analyzer = self.currentFile.analyzer
        for i, value in enumerate(basisValues):
            self.currentFile.analyzer.basisPaths[i].setMeasuredValue(value)
        # # Write basis values to file
        # basisValuesFile = \
            # self.currentFile.analyzer.writeBasisValuesToFile(basisValues)
        # self.currentFile.importBasisValues(basisValuesFile, basisValues)
        # if self.mainWindow.fileSelectWidget.widget().activeRight:
            # self.mainWindow.fileSelectWidget.widget().
            # activeRight.setAsRightView()
        self.accept()

    def on_reject(self):
        self.reject()

class BasisGenerationDialog(QtGui.QDialog):
    def __init__(self, caller, maximumErrorScaleFactor):
        QtGui.QDialog.__init__(self)
        self.caller = caller
        self.overcompleteBasisEdit = QtGui.QCheckBox("Generate overcomplete basis")
        self.overcompleteBasisEdit.setChecked(False)
        self.errorScaleFactorEdit = QtGui.QLineEdit()
        self.errorScaleFactorEdit.setText(str(maximumErrorScaleFactor))
        self.errorScaleFactorEdit.setReadOnly(True)
        self.setWindowTitle("Generate Basis")
        layout = QtGui.QGridLayout()
        layout.setSpacing(5)
        layout.addWidget(self.overcompleteBasisEdit, 0, 0, 1, 1)
        layout.addWidget(self.errorScaleFactorEdit, 1, 1)
        
        descriptionLabel = QtGui.QLabel("Maximum Error Scale Factor:")
        layout.addWidget(descriptionLabel, 1, 0)
        
        self.layout = layout
        self.setLayout(self.layout)

        self.overcompleteBasisEdit.clicked.connect(self.toggleActive)

        #Add standard buttons here at the bottom
        okButton = QtGui.QPushButton("OK")
        cancelButton = QtGui.QPushButton("Cancel")
        self.layout.addWidget(okButton, 2, 0)
        self.layout.addWidget(cancelButton, 2, 1)
        okButton.clicked.connect(self.on_accept)
        cancelButton.clicked.connect(self.on_reject)

        self.show()

    def toggleActive(self):
        self.errorScaleFactorEdit.setReadOnly(
            not self.overcompleteBasisEdit.isChecked()) 

    def on_accept(self):
        try:
            if float(str(self.errorScaleFactorEdit.text())) < 1:
                raise ValueError
            self.caller.maximumErrorScaleFactor = \
                float(str(self.errorScaleFactorEdit.text()))
            self.caller.generateOvercompleteBasis = \
                self.overcompleteBasisEdit.isChecked()
        except ValueError:
            self.caller.mainWindow.printToConsole(
                "Please enter a valid "
                "floating-point value at least 1.0.")
            return
        self.accept()

    def on_reject(self):
        self.caller.mainWindow.printToConsole("Generation of basis "
                                              "cancelled.")
        self.reject()

class GenericAnalyzer(object):
    """Function called when a slot to find a feasible path is called.
    GenericAnalyzer takes an enumCommand and creates a GenericDialog.
    After determining which file to analyze from the GenericDialog,
    GenericAnalyzer tries to create an Analyzer object for the associated
    instance. If creating the Analyzer object succeeds, GenericAnalyzer
    calls the function callEnumCommand. callEnumCommand then creates
    the files for each Path object the Analyzer object generates.
    """
    def __init__(self, enumCommand, mainWin):
        self.mainWindow = mainWin
        self.enumCommand = enumCommand
        self.numPaths = 1
        self.useObExtraction = False

    def exec_(self):
        leftTextEdit = self.mainWindow.leftTextEdit
        itemToAnalyze = leftTextEdit.fileItemObject.getAnalyzeItem()

        if not itemToAnalyze or not itemToAnalyze.canAnalyze:
            # No file has been selected or the file can not be analyzed.
            self.mainWindow.printToConsole("Not a valid file to analyze.")
        else:
            if ((itemToAnalyze.analyzer is None or
                 self.enumCommand == 0)):
                try:
                    # Create a new analyzer every time the user wants
                    # to generate the basis paths.
                    itemToAnalyze.makeAnalyzer()
                except:
                    self.mainWindow.printToConsole("Not a valid file "
                                                   "to analyze.")
                    itemToAnalyze.setAnalyze(False)
            return self.callEnumCommand(itemToAnalyze)

    def callEnumCommand(self, itemToAnalyze):
        """After an Analyzer object has been created for a given
        itemToAnalyze, create the derived files using the generating
        function specified by enumCommand.

        Arguments:
            itemToAnalyze:
                FileItem object for which the Path-derived files are
                being created.
        """
        paths = None
        
        if itemToAnalyze.analyzer is None:
            itemToAnalyze.makeAnalyzer()

        if self.enumCommand == 0:
            # currentName = itemToAnalyze.getFileName()
            # if currentName[-11:] == "-gtTEMP.xml":
                # itemToAnalyze.fileName = "%s.xml" % currentName[:-11]
            # self.writeLabels(itemToAnalyze)
            # Add inlining/including/unroll XML updates here.
            paths = itemToAnalyze.analyzer.generateBasisPaths()
            # if currentName[-11:] == "-gtTEMP.xml":
            #     itemToAnalyze.fileName = "%s.xml" % currentName[:-11]
        elif self.enumCommand == 1:
            paths = itemToAnalyze.analyzer.generatePaths(
                self.numPaths, PathType.BEST_CASE, None, self.useObExtraction
            )
        elif self.enumCommand == 2:
            paths = itemToAnalyze.analyzer.generatePaths(
                self.numPaths, PathType.WORST_CASE, None, self.useObExtraction
            )
        elif self.enumCommand == 3:
            paths = itemToAnalyze.analyzer.generatePaths(
                self.numPaths, PathType.RANDOM
            )
        elif self.enumCommand == 4:
            paths = itemToAnalyze.analyzer.generatePaths(
                self.numPaths, PathType.ALL_DECREASING, None,
                self.useObExtraction
            )
        elif self.enumCommand == 5:
            paths = itemToAnalyze.analyzer.generatePaths(
                self.numPaths, PathType.ALL_INCREASING, None,
                self.useObExtraction
            )
        else:
            return

        # The rest is handled in WorkerThread in gui.py.
        return paths


class Highlighter(object):
    """
    Wrapper class that calls GenericDialog on the enumCommand 3.
    The reason this class needs a wrapper is because all callers of
    GenericDialog must have a mainWindow attribute. Since the caller of
    GenericDialog for the highlighting case is the mainWindow itself,
    a wrapper class must be created.
    """
    def __init__(self, mainWindow):
        self.mainWindow = mainWindow

    def exec_(self):
        self.mainWindow.rightTextEdit.displayHighlights()


class Saver(object):
    def __init__(self, mainWindow, fileItemToSave):
        self.mainWindow = mainWindow
        self.fileItemToSave = fileItemToSave

    def exec_(self):
        projectConfig = self.fileItemToSave.projectConfig

        fileDialog = QtGui.QFileDialog()
        choice, _ = fileDialog.getSaveFileName(
            self.mainWindow,
            "Save GameTime GUI state to...",
            projectConfig.locationOrigDir,
            "GameTime GUI state files (*.gtg)"
        )
        if not choice:
            self.mainWindow.printToConsole("No file was selected.")
            return False

        with bz2.BZ2File(choice, "w") as fileHandler:
            # Save the fileList and mainWindow, which are not serializable,
            # to be restored later.
            tempWin = self.fileItemToSave.mainWindow
            tempList = self.fileItemToSave.fileList
            tempIndex = self.fileItemToSave.displayIndex
            self.fileItemToSave.mainWindow = None
            self.fileItemToSave.fileList = None
            self.fileItemToSave.displayIndex = None
            childIndexes = []
            for child in self.fileItemToSave.children:
                childIndexes.append(child.displayIndex)
                child.displayIndex = None
                child.mainWindow = None
                child.fileList = None

            # Dump the FileItem.
            pickle.dump(self.fileItemToSave, fileHandler)
            originalName = self.fileItemToSave.originalName
            self.mainWindow.printToConsole(
                "Current state of the analysis of the file "
                "located at %s was saved to %s." % (originalName, choice)
            )

            # Restore the mainWindow and fileList.
            self.fileItemToSave.mainWindow = tempWin
            self.fileItemToSave.fileList = tempList
            self.fileItemToSave.displayIndex = tempIndex
            for i, child in enumerate(self.fileItemToSave.children):
                child.displayIndex = childIndexes[i]
                child.mainWindow = tempWin
                child.fileList = tempList
            return True


class Loader(object):
    def __init__(self, mainWindow):
        self.mainWindow = mainWindow

    def exec_(self):
        fileDialog = QtGui.QFileDialog()
        fileDialog.setFileMode(QtGui.QFileDialog.ExistingFile)
        choice, _ = fileDialog.getOpenFileName(
            self.mainWindow,
            "Load GameTime GUI state from...",
            ".",
            "GameTime GUI state files (*.gtg)"
        )

        if not choice:
            self.mainWindow.printToConsole("No file was selected.")
            return False

        with bz2.BZ2File(choice, "r") as fileHandler:
            try:
                fileItemToLoad = pickle.load(fileHandler)
            except Exception:
                self.mainWindow.printToConsole("Invalid state file: %s" %
                                               choice)
                return False
            else:
                fileSelect = self.mainWindow.fileSelectWidget.widget()
                toLoadDisplayName = fileItemToLoad.displayName
                if toLoadDisplayName in self.mainWindow.openItems:
                    if ((not ConfirmationDialog(
                            "There is currently an analysis for the file "
                            "named %s loaded in the GUI.\nDo you want to "
                            "overwrite that analysis?" % toLoadDisplayName
                    ))).exec_():
                        return False
                    else:
                        fileSelect.removeGroup(
                            self.mainWindow.openItems[toLoadDisplayName]
                        )

                fileItemToLoad.mainWindow = self.mainWindow
                fileItemToLoad.fileList = fileSelect
                fileItemToLoad.addToMainWindow()
                self.mainWindow.addToWindow(fileItemToLoad, Window.LEFT)

                for child in fileItemToLoad.children:
                    child.mainWindow = self.mainWindow
                    child.fileList = fileItemToLoad.fileList
                    child.addToMainWindow()
                    self.mainWindow.addToWindow(child, Window.RIGHT)

                self.mainWindow.printToConsole(
                    "State of the analysis of the file "
                    "located at %s was loaded from %s." %
                    (fileItemToLoad.originalName, choice)
                )
                return True


class ConfirmationDialog(QtGui.QDialog):
    def __init__(self, text):
        QtGui.QDialog.__init__(self)
        self.setWindowTitle("Confirmation")
        # self.resize(300, 200)
        self.layout = QtGui.QGridLayout(self)
        self.layout.setSpacing(5)

        confirmText = QtGui.QLabel(text)
        self.layout.addWidget(confirmText, 0, 0)

        buttonBox = QtGui.QDialogButtonBox(Qt.Horizontal, self)
        buttonBox.setStandardButtons(
            QtGui.QDialogButtonBox.Cancel | QtGui.QDialogButtonBox.Ok
        )
        buttonBox.accepted.connect(self.accept)
        buttonBox.rejected.connect(self.reject)
        self.layout.addWidget(buttonBox, 1, 0)


class MessageDialog(QtGui.QDialog):
    def __init__(self, text, title="Message"):
        super(MessageDialog, self).__init__()
        self.setWindowTitle(title)
        # self.resize(300, 200)
        self.layout = QtGui.QGridLayout(self)
        self.layout.setSpacing(5)

        confirmText = QtGui.QLabel(text)
        self.layout.addWidget(confirmText, 0, 0, 1, 2)

        buttonBox = QtGui.QDialogButtonBox(Qt.Horizontal, self)
        buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Ok)
        buttonBox.accepted.connect(self.accept)
        self.layout.addWidget(buttonBox, 1, 0)


class BasisMessageDialog(MessageDialog):
    def __init__(self, text, mainWindow, title="Message"):
        self.mainWindow = mainWindow
        super(BasisMessageDialog, self).__init__(text, title)
        enterValuesButton = QtGui.QPushButton("Enter basis values...")
        enterValuesButton.clicked.connect(self.basisValues)
        self.layout.addWidget(enterValuesButton, 1, 1)

    def basisValues(self):
        self.accept()
        self.mainWindow.slotBasisValuesDialog()


class ExceptionMessageBox(QtGui.QMessageBox):
    def __init__(self, message, detailedMessage):
        super(ExceptionMessageBox, self).__init__(
            QtGui.QMessageBox.Critical,
            unicode("Error"),
            unicode("An exception has occurred.")
        )
        self.setInformativeText(message)
        self.setDetailedText(detailedMessage)
