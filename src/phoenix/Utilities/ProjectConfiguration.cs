/*************************************************************************************************
 * ProjectConfiguration                                                                          *
 * ============================================================================================= *
 * This file contains the class that maintains all of the information regarding                  *
 * the current GameTime project, such as the location of the file being analyzed and             *
 * the name of the function being analyzed.                                                      *
 *                                                                                               *
 * See LICENSE for full license details (BSD license).                                           *
 *************************************************************************************************/

using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Xml;


namespace Utilities
{
    /// <summary>
    /// This class maintains all of the information regarding the current GameTime project, such as
    /// the location of the file being analyzed and the name of the function being analyzed.
    /// </summary>
    public class ProjectConfiguration
    {
        #region Constructor

        /// <summary>
        /// Constructor for a ProjectConfiguration object.
        /// </summary>
        public ProjectConfiguration()
        {
            locationOrigDir = "";
            locationOrigFile = "";
            locationOrigNoExtension = "";
            nameOrigFile = "";
            nameOrigNoExtension = "";

            locationTempDir = "";
            locationTempFile = "";
            locationTempNoExtension = "";
            nameTempFile = "";
            nameTempNoExtension = "";

            locationXmlFile = "";
            nameXmlFile = "";

            func = "";
            startLabel = "";
            endLabel = "";

            included = new List<string>();
            merged = new List<string>();
            inlined = new List<string>();
            UNROLL_LOOPS = false;

            RANDOMIZE_INITIAL_BASIS = false;
            DETERMINANT_THRESHOLD = 0.001;
            MAX_INFEASIBLE_PATHS = 100;
            MODEL_AS_NESTED_ARRAYS = false;
            PREVENT_BASIS_REFINEMENT = false;
            ilpSolver = IlpSolver.PULP_DEFAULT;
            smtSolver = SmtSolver.NONE;

            debugConfig = new DebugConfiguration();
        }

        #endregion

        #region File Information

        /// <summary>
        /// Location of the directory that contains the file to be analyzed.
        /// </summary>
        public string locationOrigDir;

        /// <summary>
        /// Location of the file to be analyzed.
        /// </summary>
        public string locationOrigFile;

        /// <summary>
        /// Location of the file to be analyzed, without the extension.
        /// </summary>
        public string locationOrigNoExtension;

        /// <summary>
        /// Name of the file to be analyzed.
        /// </summary>
        public string nameOrigFile;

        /// <summary>
        /// Name of the file to be analyzed, without the extension.
        /// </summary>
        public string nameOrigNoExtension;

        /// <summary>
        /// Location of the temporary folder that will store the temporary
        /// files generated by the GameTime toolflow.
        /// </summary>
        public string locationTempDir;

        /// <summary>
        /// Pre-constructed location of the temporary file that will be anaylzed by GameTime.
        /// </summary>
        public string locationTempFile;

        /// <summary>
        /// Location of the temporary file that will be analyzed by GameTime,
        /// without the extension.
        /// </summary>
        public string locationTempNoExtension;

        /// <summary>
        /// Name of the temporary file that will be analyzed by GameTime.
        /// </summary>
        public string nameTempFile;

        /// <summary>
        /// Name of the temporary file that will be analyzed by GameTime,
        /// without the extension.
        /// </summary>
        public string nameTempNoExtension;

        /// <summary>
        /// Location of the temporary XML file that stores the project configuration information.
        /// </summary>
        public string locationXmlFile;

        /// <summary>
        /// Name of the temporary XML file that stores the project configuration information.
        /// </summary>
        public string nameXmlFile;

        /// <summary>
        /// Name of the function to analyze.
        /// </summary>
        public string func;

        /// <summary>
        /// Label to start analysis at, if any.
        /// </summary>
        public string startLabel;

        /// <summary>
        /// Label to end analysis at, if any.
        /// </summary>
        public string endLabel;

        #endregion

        #region Preprocessing Variables and Flags

        /// <summary>
        /// List of the locations of directories that contain other files
        /// that need to be compiled and linked, but not preprocessed, with
        /// the file that contains the function to be analyzed,
        /// such as header files.
        /// </summary>
        public List<string> included;

        /// <summary>
        /// List of the locations of other files to be merged and preprocessed
        /// with the file that contains the function to be analyzed.
        /// </summary>
        public List<string> merged;

        /// <summary>
        /// List of the names of functions to inline.
        /// </summary>
        public List<string> inlined;

        /// <summary>
        /// Whether to unroll loops present in the function being analyzed.
        /// </summary>
        public bool UNROLL_LOOPS;

        #endregion

        #region Analysis Variables and Flags

        /// <summary>
        /// Whether to randomize the basis that GameTime starts the analysis with.
        /// </summary>
        public bool RANDOMIZE_INITIAL_BASIS;

        /// <summary>
        /// Threshold below which the determinant of the basis matrix
        /// is considered "too small".
        /// </summary>
        public double DETERMINANT_THRESHOLD;

        /// <summary>
        /// Maximum number of infeasible candidate paths that can be explored before
        /// a row of a basis matrix is considered "bad".
        /// </summary>
        public int MAX_INFEASIBLE_PATHS;

        /// <summary>
        /// Whether to model multi-dimensional arrays as nested arrays,
        /// or arrays whose elements can also be arrays, in an SMT query.
        /// </summary>
        public bool MODEL_AS_NESTED_ARRAYS;

        /// <summary>
        /// Whether to prevent the refinement of the basis into a 2-barycentric spanner.
        /// </summary>
        public bool PREVENT_BASIS_REFINEMENT;

        /// <summary>
        /// Enumeration that lists the possible backend integer linear programming solvers.
        /// </summary>
        public enum IlpSolver
        {
            /// <summary>
            /// Default integer linear programming solver of the PuLP package.
            /// </summary>
            PULP_DEFAULT,

            /// <summary>
            /// CBC mixed integer linear programming solver.
            /// </summary>
            CBC,

            /// <summary>
            /// Version of CBC provided with the PuLP package.
            /// </summary>
            CBC_PULP,

            /// <summary>
            /// IBM ILOG CPLEX Optimizer.
            /// </summary>
            CPLEX,

            /// <summary>
            /// GNU Linear Programming Kit (GLPK).
            /// </summary>
            GLPK,

            /// <summary>
            /// Gurobi Optimizer.
            /// </summary>
            GUROBI,

            /// <summary>
            /// FICO Xpress Optimizer.
            /// </summary>
            XPRESS
        };

        /// <summary>
        /// Integer linear programming solver used to solve integer linear programs
        /// to generate candidate paths.
        /// </summary>
        public IlpSolver ilpSolver;

        /// <summary>
        /// Enumeration that lists the possible backend SMT solvers.
        /// </summary>
        public enum SmtSolver
        {
            /// <summary>
            /// Z3, the SMT solver from Microsoft.
            /// </summary>
            Z3,

            /// <summary>
            /// Boolector SMT solver.
            /// </summary>
            BOOLECTOR,

            /// <summary>
            /// No SMT solver.
            /// </summary>
            NONE
        };

        /// <summary>
        /// SMT solver used to check the satisfiability of SMT queries.
        /// </summary>
        public SmtSolver smtSolver;

        #endregion

        #region Debugging

        /// <summary>
        /// Debugging configuration.
        /// </summary>
        public DebugConfiguration debugConfig;

        #endregion

        #region I/O Functions

        /// <summary>
        /// Obtains the text from the XML node provided.
        /// </summary>
        ///
        /// <param name="node">Node to obtain the text content from.</param>
        /// <returns>The text content of the node provided.</returns>
        public static string GetXmlText(XmlNode node)
        {
            return node.InnerText.Trim();
        }

        /// <summary>
        /// Reads the project configuration information from the XML file provided.
        /// </summary>
        ///
        /// <param name="projectConfigFile">Path to XML file that contains
        /// project configuration information.</param>
        /// <param name="config">Conifguration object that contains information
        /// about the current configuration of GameTime.</param>
        /// <returns>ProjectConfiguration object that contains information from
        /// the file provided.</returns>
        public static ProjectConfiguration ReadProjectConfigFile(string projectConfigFile,
            Utilities.Configuration config) {
            if (!File.Exists(projectConfigFile))
            {
                Console.Out.WriteLine("PHOENIX: Cannot find project configuration file {0}.",
                    projectConfigFile);
                Environment.Exit(2);
                return null;
            }
            else
            {
                XmlDocument projectConfigXmlDoc = new XmlDocument();
                projectConfigXmlDoc.Load(projectConfigFile);

                ProjectConfiguration projectConfig = new ProjectConfiguration();
                XmlElement projectConfigDocElt = projectConfigXmlDoc.DocumentElement;

                /* Process information about the file to be analyzed. */
                XmlNodeList fileInfo = projectConfigDocElt.GetElementsByTagName("file");
                XmlNode fileNode = fileInfo[0];

                foreach (XmlNode node in fileNode.ChildNodes)
                {
                    if (node.NodeType == XmlNodeType.Element)
                    {
                        string nodeText = ProjectConfiguration.GetXmlText(node);
                        string nodeName = node.Name;

                        switch (nodeName)
                        {
                            case "location":
                                /* Infer the full path of the file to analyze. */
                                string fileToAnalyze = nodeText;
                                projectConfig.locationOrigFile = Path.GetFullPath(fileToAnalyze);

                                /* Infer the directory that contains the file to analyze. */
                                string locOrigWithExtension = projectConfig.locationOrigFile;
                                string locationOrigDir =
                                    Path.GetDirectoryName(locOrigWithExtension);
                                projectConfig.locationOrigDir = locationOrigDir;

                                /* Infer the name of the file without the file extension and
                                 * the file path without the file extension. */
                                string nameOrigFile = Path.GetFileName(locOrigWithExtension);
                                projectConfig.nameOrigFile = nameOrigFile;
                                string nameOrigNoExtension =
                                    Path.GetFileNameWithoutExtension(locOrigWithExtension);
                                projectConfig.nameOrigNoExtension = nameOrigNoExtension;
                                string locOrigNoExtension =
                                    Path.Combine(locationOrigDir, nameOrigNoExtension);
                                projectConfig.locationOrigNoExtension = locOrigNoExtension;

                                /* Infer the name of the temporary directory where GameTime
                                 * stores its temporary files during its toolflow. */
                                String locationTempDir = locOrigNoExtension + config.TEMP_SUFFIX;
                                projectConfig.locationTempDir = locationTempDir;

                                /* Create the temporary directory, if not already present. */
                                if (!Directory.Exists(locationTempDir))
                                {
                                    Directory.CreateDirectory(locationTempDir);
                                }

                                /* Infer the name and location of the temporary file to be
                                 * analyzed by GameTime, both with and without the extension. */
                                string nameTempNoExtension =
                                    nameOrigNoExtension + config.TEMP_SUFFIX;
                                projectConfig.nameTempNoExtension = nameTempNoExtension;
                                string nameTempFile = nameTempNoExtension + ".c";
                                projectConfig.nameTempFile = nameTempFile;

                                String locationTempFile =
                                    Path.Combine(locationTempDir, nameTempFile);
                                projectConfig.locationTempFile = locationTempFile;
                                string locTempNoExtension =
                                    Path.Combine(locationTempDir, nameTempNoExtension);
                                projectConfig.locationTempNoExtension = locTempNoExtension;

                                /* Infer the name and location of the temporary XML file that
                                 * stores the project configuration information. */
                                String nameXmlFile = config.TEMP_PROJECT_CONFIG + ".xml";
                                projectConfig.nameXmlFile = nameXmlFile;
                                String locXmlFile = Path.Combine(locationTempDir, nameXmlFile);
                                projectConfig.locationXmlFile = locXmlFile;
                                break;
                            case "analysis-function":
                                projectConfig.func = nodeText;
                                break;
                            case "start-label":
                                projectConfig.startLabel = nodeText;
                                break;
                            case "end-label":
                                projectConfig.endLabel = nodeText;
                                break;
                            default:
                                Console.Out.WriteLine("PHOENIX: Unrecognized tag: {0}", nodeName);
                                Environment.Exit(2);
                                return null;
                        }
                    }
                }

                /* Process the preprocessing flags and variables. */
                XmlNodeList preprocessingInfo =
                    projectConfigDocElt.GetElementsByTagName("preprocess");
                XmlNode preprocessingNode = preprocessingInfo[0];

                foreach (XmlNode node in preprocessingNode.ChildNodes)
                {
                    if (node.NodeType == XmlNodeType.Element)
                    {
                        string nodeText = ProjectConfiguration.GetXmlText(node);
                        string nodeName = node.Name;

                        switch (nodeName)
                        {
                            case "include":
                                string[] included = Regex.Split(nodeText, @"[\s,]+");
                                foreach (string includePath in included)
                                {
                                    if (includePath != "")
                                    {
                                        projectConfig.included.Add(includePath);
                                    }
                                }
                                break;
                            case "merge":
                                string[] merged = Regex.Split(nodeText, @"[\s,]+");
                                foreach (string mergePath in merged)
                                {
                                    if (mergePath != "")
                                    {
                                        projectConfig.merged.Add(mergePath);
                                    }
                                }
                                break;
                            case "inline":
                                string[] inlined = Regex.Split(nodeText, @"[\s,]+");
                                foreach (string inlineFunc in inlined)
                                {
                                    if (inlineFunc != "")
                                    {
                                        projectConfig.inlined.Add(inlineFunc);
                                    }
                                }
                                break;
                            case "unroll-loops":
                                projectConfig.UNROLL_LOOPS = true;
                                break;
                            default:
                                Console.Out.WriteLine("PHOENIX: Unrecognized tag: {0}", nodeName);
                                Environment.Exit(2);
                                return null;
                        }
                    }
                }

                /* Process the analysis flags. */
                XmlNodeList analysisInfo =
                    projectConfigDocElt.GetElementsByTagName("analysis");
                XmlNode analysisNode = analysisInfo[0];

                foreach (XmlNode node in analysisNode.ChildNodes)
                {
                    if (node.NodeType == XmlNodeType.Element)
                    {
                        string nodeText = ProjectConfiguration.GetXmlText(node);
                        string nodeName = node.Name;

                        switch (nodeName)
                        {
                            case "randomize-initial-basis":
                                projectConfig.RANDOMIZE_INITIAL_BASIS = true;
                                break;
                            case "determinant-threshold":
                                projectConfig.DETERMINANT_THRESHOLD = Convert.ToDouble(nodeText);
                                break;
                            case "max-infeasible-paths":
                                projectConfig.MAX_INFEASIBLE_PATHS = Convert.ToInt32(nodeText);
                                break;
                            case "model-as-nested-arrays":
                                projectConfig.MODEL_AS_NESTED_ARRAYS = true;
                                break;
                            case "prevent-basis-refinement":
                                projectConfig.PREVENT_BASIS_REFINEMENT = true;
                                break;
                            case "ilp-solver":
                                nodeText = nodeText.ToLower();
                                projectConfig.ilpSolver =
                                    (nodeText.Equals("cbc")) ? IlpSolver.CBC :
                                    (nodeText.Equals("cbc-pulp")) ? IlpSolver.CBC_PULP :
                                    (nodeText.Equals("cplex")) ? IlpSolver.CPLEX :
                                    (nodeText.Equals("glpk")) ? IlpSolver.GLPK :
                                    (nodeText.Equals("gurobi")) ? IlpSolver.GUROBI :
                                    (nodeText.Equals("xpress")) ? IlpSolver.XPRESS :
                                    IlpSolver.PULP_DEFAULT;
                                break;
                            case "smt-solver":
                                nodeText = nodeText.ToLower();
                                projectConfig.smtSolver =
                                    (nodeText.Equals("z3")) ? SmtSolver.Z3 :
                                    (nodeText.StartsWith("boolector")) ? SmtSolver.BOOLECTOR :
                                    SmtSolver.NONE;
                                break;
                            default:
                                Console.Out.WriteLine("PHOENIX: Unrecognized tag: {0}", nodeName);
                                Environment.Exit(2);
                                return null;
                        }
                    }
                }

                /* Process the debug flags. */
                XmlNodeList debugInfo = projectConfigDocElt.GetElementsByTagName("debug");
                XmlNode debugNode = debugInfo[0];

                foreach (XmlNode node in debugNode.ChildNodes)
                {
                    if (node.NodeType == XmlNodeType.Element)
                    {
                        string nodeText = ProjectConfiguration.GetXmlText(node);
                        string nodeName = node.Name;

                        switch (nodeName)
                        {
                            case "keep-cil-temps":
                                projectConfig.debugConfig.KEEP_CIL_TEMPS = true;
                                break;
                            case "dump-ir":
                                projectConfig.debugConfig.DUMP_IR = true;
                                break;
                            case "keep-ilp-solver-output":
                                projectConfig.debugConfig.KEEP_ILP_SOLVER_OUTPUT = true;
                                break;
                            case "dump-path":
                                projectConfig.debugConfig.DUMP_PATH = true;
                                break;
                            case "dump-all-paths":
                                projectConfig.debugConfig.DUMP_ALL_PATHS = true;
                                break;
                            case "dump-instruction-trace":
                                projectConfig.debugConfig.DUMP_INSTRUCTION_TRACE = true;
                                break;
                            case "dump-smt-trace":
                                projectConfig.debugConfig.DUMP_SMT_TRACE = true;
                                break;
                            case "dump-all-queries":
                                projectConfig.debugConfig.DUMP_ALL_QUERIES = true;
                                break;
                            case "keep-parser-output":
                                projectConfig.debugConfig.KEEP_PARSER_OUTPUT = true;
                                break;
                            case "keep-simulator-output":
                                projectConfig.debugConfig.KEEP_SIMULATOR_OUTPUT = true;
                                break;
                            default:
                                Console.Out.WriteLine("PHOENIX: Unrecognized tag: {0}", nodeName);
                                Environment.Exit(2);
                                return null;
                        }
                    }
                }

                return projectConfig;
            }
        }

        #endregion
    }

    /// <summary>
    /// This class stores debugging configuration information, which
    /// determines the debugging output that is shown.
    /// </summary>
    public class DebugConfiguration
    {
        #region Constructor

        /// <summary>
        /// Constructor for a DebugConfiguration object.
        /// </summary>
        public DebugConfiguration()
        {
            KEEP_CIL_TEMPS = false;
            DUMP_IR = false;
            KEEP_ILP_SOLVER_OUTPUT = false;
            DUMP_PATH = false;
            DUMP_ALL_PATHS = false;
            DUMP_INSTRUCTION_TRACE = false;
            DUMP_SMT_TRACE = false;
            DUMP_ALL_QUERIES = false;
            KEEP_PARSER_OUTPUT = false;
            KEEP_SIMULATOR_OUTPUT = false;
        }

        #endregion

        #region Debugging Flags

        /// <summary>
        /// Keep the temporary files that CIL generates during its analysis.
        /// </summary>
        public bool KEEP_CIL_TEMPS;

        /// <summary>
        /// Dump the Phoenix intermediate representation of the function under analysis to a file.
        /// </summary>
        public bool DUMP_IR;

        /// <summary>
        /// Keep debugging information and files produced by the integer linear programming solver.
        /// </summary>
        public bool KEEP_ILP_SOLVER_OUTPUT;

        /// <summary>
        /// Dump information about the path being traced.
        /// </summary>
        public bool DUMP_PATH;

        /// <summary>
        /// Dump information about all of the paths that have been traced
        /// during analysis to a file.
        /// </summary>
        public bool DUMP_ALL_PATHS;

        /// <summary>
        /// Dump information produced when an IR-level instruction is traced backward.
        /// </summary>
        public bool DUMP_INSTRUCTION_TRACE;

        /// <summary>
        /// Dump information produced when an SMT query is created.
        /// </summary>
        public bool DUMP_SMT_TRACE;

        /// <summary>
        /// Dump information about all of the SMT queries that
        /// have been made during analysis to a file.
        /// </summary>
        public bool DUMP_ALL_QUERIES;

        /// <summary>
        /// Keep the debugging information and temporary files produced by the parser.
        /// </summary>
        public bool KEEP_PARSER_OUTPUT;

        /// <summary>
        /// Keep the temporary files produced by a simulator when
        /// measuring the value of a path.
        /// </summary>
        public bool KEEP_SIMULATOR_OUTPUT;

        #endregion
    }
}
