#!/usr/bin/env python

"""Exposes classes and functions to maintain a representation of,
and information about, an SMT query.
"""

"""See the LICENSE file, located in the root directory of
the source distribution and
at http://verifun.eecs.berkeley.edu/gametime/about/LICENSE,
for details on the GameTime license and authors.
"""


from gametime.gametimeError import GameTimeError


class Satisfiability(object):
    """Represents the satisfiability of an SMT query."""
    #: The satisfiability of the SMT query has not been tested.
    UNTESTED = 0
    #: The SMT query is satisfiable.
    SAT = 1
    #: The SMT query is unsatisfiable.
    UNSAT = 2
    #: The satisfiability of the SMT query is unknown.
    UNKNOWN = 3


class Query(object):
    """Maintains a representation of, and information about, an SMT query.

    Attributes:
        queryStr:
            String that contains an SMT query whose satisfiability
            needs to be checked.
    """

    def __init__(self, queryStr):
        #: String that contains the SMT query whose
        #: satisfiability needs to be checked.
        self.queryStr = queryStr

        #: Satisfiability of the SMT query.
        self.satisfiability = Satisfiability.UNTESTED

        #: Model generated by an SMT solver in response to the SMT query, if
        #: the query is satisfiable. The model is represented by
        #: a :class:`~gametime.smt.model.Model` object.
        self.model = None

        #: Unsatisfiable core generated by an SMT solver in response to
        #: the SMT query, if the query is unsatisfiable. The unsatisfiable
        #: core is represented as a list of non-negative integers, each of
        #: which is the number of a constraint.
        self.unsatCore = []

    def labelSat(self, model):
        """Labels the SMT query as satisfiable, and associates
        the satisfiable query with a model generated by an SMT solver.

        Arguments:
            model:
                Model generated by an SMT solver in response to
                the SMT query. The model is represented by
                a :class:`~gametime.smt.model.Model` object.
        """
        self.satisfiability = Satisfiability.SAT
        self.model = model
        self.unsatCore = []

    def labelUnsat(self, unsatCore):
        """Labels the SMT query as unsatisfiable, and associates
        the unsatisfiable query with an unsatisfiable core generated by
        an SMT solver.

        Arguments:
            unsatCore:
                Unsatisfiable core generated by an SMT solver in response to
                the SMT query. The unsatisfiable core is represented as
                a list of non-negative integers, each of which is the number
                of a constraint.
        """
        self.satisfiability = Satisfiability.UNSAT
        self.model = None
        self.unsatCore = unsatCore

    def labelUnknown(self):
        """Labels the satisfiability of the SMT query as unknown."""
        self.satisfiability = Satisfiability.UNKNOWN
        self.model = None
        self.unsatCore = []

    def reset(self):
        """Resets the SMT query."""
        self.satisfiability = Satisfiability.UNTESTED
        self.model = None
        self.unsatCore = []

    def getSmtQuery(self):
        """
        Returns:
            String representation of the SMT query associated
            with this Query object.
        """
        return self.queryStr

    def writeSmtQueryToFile(self, location):
        """Writes the SMT query associated with this
        :class:`~gametime.smt.query.Query` object to a file.

        Arguments:
            location:
                Location of the file.
        """
        try:
            smtQueryFileHandler = open(location, "w")
        except EnvironmentError as e:
            errMsg = ("Error writing the SMT query to a file "
                      "located at %s: %s" % (location, e))
            raise GameTimeError(errMsg)
        else:
            with smtQueryFileHandler:
                smtQueryFileHandler.write(self.getSmtQuery())

    def getModel(self):
        """
        Returns:
            String representation of the model generated by
            an SMT solver in response to the SMT query, if
            the query is satisfiable.
        """
        return str(self.model) if self.model is not None else ""

    def writeModelToFile(self, location):
        """Writes the model generated by an SMT solver in response to
        the SMT query, if the query is satisfiable, to a file.

        Arguments:
            location:
                Location of the file.
        """
        try:
            modelFileHandler = open(location, "w")
        except EnvironmentError as e:
            errMsg = ("Error writing the model generated by an SMT solver "
                      "in response to the SMT query to a file located at %s: "
                      "%s" % (location, e))
            raise GameTimeError(errMsg)
        else:
            with modelFileHandler:
                modelFileHandler.write(self.getModel())

    def getUnsatCore(self):
        """
        Returns:
            String representation of the unsatisfiable core
            generated by an SMT solver in response to
            the SMT query, if the query is unsatisfiable.
        """
        return " ".join(str(conditionNum) for conditionNum in self.unsatCore)

    def writeUnsatCoreToFile(self, location):
        """Writes the unsatisfiable core generated by an SMT solver
        in response to the SMT query, if the query is unsatisfiable,
        to a file.

        Arguments:
            location:
                Location of the file.
        """
        try:
            unsatCoreFileHandler = open(location, "w")
        except EnvironmentError as e:
            errMsg = ("Error writing the unsatisfiable core generated by "
                      "an SMT solver in response to the SMT query to "
                      "a file located at %s: %s" % (location, e))
            raise GameTimeError(errMsg)
        else:
            with unsatCoreFileHandler:
                unsatCoreFileHandler.write(self.getUnsatCore())

    def __str__(self):
        result = []
        result.append(self.queryStr)
        if self.satisfiability is Satisfiability.SAT:
            result.append("Query is SATISFIABLE.\n")
            result.append("Model:")
            result.append(self.getModel())
        elif self.satisfiability is Satisfiability.UNSAT:
            result.append("Query is UNSATISFIABLE.\n")
            result.append("Unsatisfiable core:")
            result.append(self.getUnsatCore())
        elif self.satisfiability is Satisfiability.UNKNOWN:
            result.append("Query has UNKNOWN satisfiability.")
        else:
            result.append("Query has not yet been tested.")
        return "\n".join(result)


def readQueryFromFile(location):
    """Reads an SMT query from the file provided.

    Arguments:
        location:
            Location of the file that contains an SMT query.

    Returns:
        :class:`~gametime.smt.query.Query` object
        that represents the SMT query.
    """
    try:
        queryFileHandler = open(location, "r")
    except EnvironmentError as e:
        errMsg = ("Error reading the SMT query from the file "
                  "located at %s: %s" % (location, e))
        raise GameTimeError(errMsg)
    else:
        with queryFileHandler:
            return Query(queryFileHandler.read())
