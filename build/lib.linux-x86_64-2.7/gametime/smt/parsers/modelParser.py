#!/usr/bin/env python

"""Exposes classes and functions to parse the models
generated by SMT solvers in response to satisfiable SMT queries.
"""

"""See the LICENSE file, located in the root directory of
the source distribution and
at http://verifun.eecs.berkeley.edu/gametime/about/LICENSE,
for details on the GameTime license and authors.
"""


import re

import ply.yacc as yacc

from gametime.defaults import config, logger
from gametime.gametimeError import GameTimeError
from gametime.smt.parsers.modelLexer import ModelLexer


class Mapping(object):
    """Stores information about a mapping, as described by a model
    produced by an SMT solver in response to a satisfiable SMT query.
    This mapping can be, for example, a function or an array.

    Attributes:
        modelParser:
            :class:`~gametime.smt.parsers.modelParser.ModelParser` object
            that contains this
            :class:`~gametime.smt.parsers.modelParser.Mapping` object.
        name:
            Name of the mapping.
        defaultOutput:
            Default output of the mapping.
    """

    def __init__(self, modelParser, name="", defaultOutput=0):
        #: :class:`~gametime.smt.parsers.modelParser.ModelParser` object
        #: that contains this
        #: :class:`~gametime.smt.parsers.modelParser.Mapping` object.
        self.modelParser = modelParser

        #: Name of the mapping.
        self.name = name

        #: Default output of the mapping.
        self.defaultOutput = defaultOutput

        #: Dictionary that maps inputs to the corresponding outputs.
        self.outputs = {}

    def add(self, inputVal, outputVal):
        """Adds a mapping between the input value provided and
        the corresponding output value.

        Arguments:
            inputVal:
                Input value to add mapping for.
            outputVal:
                Output value that corresponds to the input value.
        """
        self.outputs[inputVal] = outputVal

    def get(self, inputVal, projectConfig):
        """Gets the output value that the input value provided is mapped to.

        Arguments:
            inputVal:
                Input value.
            projectConfig:
                :class:`~gametime.projectConfiguration.ProjectConfiguration`
                object that represents the configuration of a GameTime project.

        Returns:
            Output value that the input value is mapped to.
        """
        return self.outputs.get(inputVal, self.defaultOutput)


class ModelParser(object):
    """Parses the models generated by SMT solvers."""

    def __init__(self):
        #: Dictionary that stores all assignments created while parsing.
        self.allAssignments = {}

        #: Dictionary that stores all of the
        #: :class:`~gametime.smt.parsers.modelParser.Mapping` objects
        #: created while parsing, indexed by mapping name.
        self.allMappings = {}

        #: Dictionary that maps a temporary array index number to the value
        #: assigned to the corresponding temporary array index.
        self.arrayTempIndexVals = {}

        #: :class:`~gametime.smt.parsers.modelParser.ModelLexer` object that
        #: performs the lexical analysis of the models generated by
        #: an SMT solver.
        self.modelLexer = ModelLexer()

    def reset(self):
        """Resets the model parser."""
        self.allAssignments = {}
        self.allMappings = {}
        self.arrayTempIndexVals = {}

    ### PARSER HELPER FUNCTIONS ###
    @staticmethod
    def hexToDec(hexNum):
        """
        Arguments:
            hexNum:
                Hexadecimal number string.

        Returns:
            Decimal number whose hexadecimal number equivalent is provided.
        """
        return int(hexNum, 16)

    @staticmethod
    def decToHex(decNum):
        """
        Arguments:
            decNum:
                Decimal number.

        Returns:
            Hexadecimal number equivalent of the decimal number provided,
            as a string.
        """
        result = hex(decNum)
        if result.endswith("L"):
            result = result[:-1]
        return result

    @staticmethod
    def binToDec(binNum):
        """
        Arguments:
            binNum:
                Binary number string.

        Returns:
            Decimal number whose binary number equivalent is provided.
        """
        return int(binNum, 2)

    @staticmethod
    def decToBin(decNum):
        """
        Arguments:
            decNum:
                Decimal number.

        Returns:
            Binary number equivalent of the decimal number provided,
            as a string.
        """
        return bin(decNum)

    def _isConstraintVar(self, varName):
        """
        Arguments:
            varName:
                Name of the variable.

        Returns:
            `True` if, and only if, the input string represents
            a Boolean variable that is associated with a constraint.
        """
        return varName.startswith(config.IDENT_CONSTRAINT)

    def _getConstraintVarNum(self, varName):
        """
        Arguments:
            varName:
                Name of the Boolean variable.

        Returns:
            Number of the constraint that the Boolean variable
            is associated with.
        """
        return int(varName[len(config.IDENT_CONSTRAINT):])

    def _isTemporaryCopy(self, varName):
        """
        Arguments:
            varName:
                Name of the variable.

        Returns:
            `True` if, and only if, the input string represents
            a temporary copy of another variable.
        """
        return varName.endswith(">")

    def _getOriginalVarName(self, varName):
        """
        Arguments:
            varName:
                Name of the variable.

        Returns:
            Original name of the variable, without the annotations
            that indicate a temporary copy of the variable.
        """
        return varName.split("<")[0]

    def _isTemporaryPointerVar(self, varName):
        """
        Arguments:
            varName:
                Name of the variable.

        Returns:
            `True` if, and only if, the input string represents
            a temporary pointer variable.
        """
        return varName.startswith(config.IDENT_TEMPPTR)

    def _isEfcVar(self, varName):
        """
        Arguments:
            varName:
                Name of the variable.

        Returns:
            `True` if, and only if, the input string represents
            a temporary variable that replaces a non-inlined function call.
        """
        return varName.startswith(config.IDENT_EFC)

    def _isIndexVar(self, varName):
        """
        Arguments:
            varName:
                Name of the variable.

        Returns:
            `True` if, and only if, the input string represents
            a temporary array index variable.
        """
        return varName.startswith(config.IDENT_TEMPINDEX)

    def _getIndexVarNumber(self, varName):
        """
        Arguments:
            varName:
                Input temporary array index variable name.

        Returns:
            Number of the temporary array index variable.
        """
        return int(varName[len(config.IDENT_TEMPINDEX):])

    def _isAggregate(self, varName):
        """
        Arguments:
            varName:
                Name of the variable.

        Returns:
            `True` if, and only if, the input string represents
            an aggregate object.
        """
        return varName.startswith(config.IDENT_AGGREGATE)

    def _getAggregateName(self, varName):
        """
        Arguments:
            varName:
                Input variable name.

        Returns:
            Name of an aggregate object from the input variable name.
        """
        return varName[len(config.IDENT_AGGREGATE):]

    def _isField(self, varName):
        """
        Arguments:
            varName:
                Name of the variable.

        Returns:
            `True` if, and only if, the input string represents
            an aggregate field.
        """
        return varName.startswith(config.IDENT_FIELD)

    def _getFieldName(self, fieldArrayName):
        """
        Arguments:
            fieldArrayName:
                Name of the array for the aggregate field.

        Returns:
            Name of an aggregate field from the name of the array
            for the field.
        """
        matching = re.match(config.IDENT_FIELD +
                            r"(?P<fieldName>(\w+))" +
                            config.IDENT_AGGREGATE,
                            fieldArrayName)
        if matching is None:
            errMsg = ("Input name does not have an aggregate field name: %s" %
                      fieldArrayName)
            raise GameTimeError(errMsg)
        return matching.group("fieldName")

    def _getPrefixes(self, aggAccess):
        """
        Arguments:
            aggAccess:
                Input aggregate access.

        Returns:
            List of all possible prefixes of the input aggregate access.
            For example, the list of prefixes of the aggregate access
            `a.b.c` are `a` and `a.b`.
        """
        fields = aggAccess.split(".")
        prefixes = []
        for i in range(1, len(fields)):
            prefixes.append(".".join(fields[:i]))
        return prefixes

    def _getArrayAccess(self, arrayName, tempIndices, aggIndexExprs):
        """
        Returns the string representation of an access into an
        array or an aggregate.

        @param arrayName Name of the array (either a C-array or
        the array associated with the field of an aggregate).
        @param tempIndices Number of the temporary indices used
        to access the array.
        @param aggIndexExprs Dictionary that maps a temporary index
        number (of an aggregate access) to an IndexExpression.
        @retval String representation of the access into an array
        or an aggregate.
        """
        if len(tempIndices) == 0:
            return (self._getAggregateName(arrayName) if
                    self._isAggregate(arrayName) else arrayName)
        elif len(tempIndices) == 1:
            index = tempIndices[0]
            if self._isField(arrayName):
                aggIndexExpr = aggIndexExprs[index]
                return (self._getArrayAccess(aggIndexExpr.getName(),
                                             aggIndexExpr.getIndices(),
                                             aggIndexExprs) +
                        "." + self._getFieldName(arrayName))
            else:
                hexTempIndexVal = \
                ModelParser.decToHex(self.arrayTempIndexVals[index])
                return arrayName + "[" + str(hexTempIndexVal) + "]"
        else:
            hexTempIndexVal = \
            ModelParser.decToHex(self.arrayTempIndexVals[tempIndices[-1]])
            return (self._getArrayAccess(arrayName, tempIndices[:-1],
                                         aggIndexExprs) +
                    "[" + str(hexTempIndexVal) + "]")

    def _getArrayAccessValue(self, mapping, tempIndices, projectConfig):
        """
        Returns the value obtained by an array access.

        @param mapping Mapping object associated with the array.
        @param tempIndices Tuple of the numbers of the temporary
        indices used in the array access.
        @param projectConfig ProjectConfiguration object.
        @retval Value obtained by the array access that uses the
        input tuple of indices.
        """
        correctedIndices = \
        tuple(self.arrayTempIndexVals[index] for index in tempIndices)
        return mapping.get(correctedIndices, projectConfig)

    def _getAssignments(self, arrayAccesses, aggIndexExprs, projectConfig):
        """
        Helper method for the `parseModel' method. After a model has
        been parsed, and the appropriate information from the model
        has been obtained and stored, this method returns a dictionary
        that maps source-level variables to the values assigned by the model.

        @pre A model has been parsed.
        @param arrayAccesses Dictionary that maps an array name to
        a list of tuples, each of which contains the numbers of
        the temporary index variables in an array access.
        @param aggIndexExprs Dictionary that maps a temporary index
        number (of an aggregate access) to an IndexExpression object.
        @param projectConfig ProjectConfiguration object.
        """
        result = {}

        # Set that stores all of the variables whose assignments must
        # be deleted before the result is returned to the user.
        toDelete = set()

        # Generate the assignments for the indices in arrays and the
        # fields in aggregates that will be accessed along a path in
        # the program.
        for arrayName in arrayAccesses:
            if self._isTemporaryPointerVar(arrayName):
                continue
            mapping = self.allMappings.get(arrayName, Mapping(self))

            arrayAccessIndices = arrayAccesses[arrayName]
            for indices in arrayAccessIndices:
                assigned = \
                self._getArrayAccess(arrayName, indices, aggIndexExprs)
                valueAssigned = \
                self._getArrayAccessValue(mapping, indices, projectConfig)
                self.allAssignments[assigned] = valueAssigned

                # Add the prefixes of the access to the set of
                # assignments to delete. If the assignment is made
                # to a field of an aggregate, the assignment to
                # prefixes must not be present.
                toDelete.update(self._getPrefixes(assigned))

        # Add all the assignments to the result.
        for assigned in self.allAssignments:
            if (assigned not in toDelete and
                not self._isTemporaryCopy(assigned) and
                not self._isEfcVar(assigned) and
                not self._isAggregate(assigned)):
                valueAssigned = self.allAssignments[assigned]
                result[assigned] = ModelParser.decToHex(valueAssigned)

        return result

    def parseModel(self, model, arrayAccesses, aggIndexExprs, projectConfig):
        """
        Parses the model generated by an SMT solver in response to
        a satisfiable query, and returns a dictionary that maps
        source-level variables to the values assigned by the model.

        @param model Model generated by an SMT solver in response to
        a satisfiable query.
        @param arrayAccesses Dictionary that maps an array name to
        a list of tuples, each of which contains the numbers of
        the temporary index variables in an array access.
        @param aggIndexExprs Dictionary that maps a temporary index
        number (of an aggregate access) to an IndexExpression object.
        @param projectConfig ProjectConfiguration object.
        @retval Dictionary that maps source-level variables to
        the values assigned by the model.
        """
        self.reset()

        if projectConfig.debugConfig.KEEP_PARSER_OUTPUT:
            logger.info("Model to parse:")
            logger.info(str(model))

        if projectConfig.debugConfig.KEEP_PARSER_OUTPUT:
            self.modelLexer.build(debug=True, debuglog=logger,
                                  errorlog=logger,
                                  outputdir=projectConfig.locationTempDir)
        else:
            self.modelLexer.build(debug=False)
        self.modelLexer.input(str(model))

        self.tokens = self.modelLexer.tokens
        if projectConfig.debugConfig.KEEP_PARSER_OUTPUT:
            parser = yacc.yacc(debug=True, debuglog=logger, errorlog=logger,
                               module=self,
                               outputdir=projectConfig.locationTempDir,
                               write_tables=0)
        else:
            parser = yacc.yacc(debug=False, module=self, write_tables=0)
        parser.parse(str(model), lexer=self.modelLexer)

        return self._getAssignments(arrayAccesses, aggIndexExprs, projectConfig)

    ### PARSER GRAMMAR RULES ###
    def p_error(self, p):
        errMsg = "Syntax error in input: '%s' " % p.value
        raise GameTimeError(errMsg)
