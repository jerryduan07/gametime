#!/usr/bin/env python

"""Exposes classes and functions to parse the models
generated by the Boolector SMT solver.
"""

"""See the LICENSE file, located in the root directory of
the source distribution and
at http://verifun.eecs.berkeley.edu/gametime/about/LICENSE,
for details on the GameTime license and authors.
"""


from gametime.defaults import config
from gametime.smt.parsers.modelParser import Mapping, ModelParser
from gametime.smt.parsers.boolectorModelLexer import BoolectorModelLexer


class BoolectorArray(Mapping):
    """Stores information about an array, as described by a model produced
    by the Boolector SMT solver in response to a satisfiable SMT query.

    Attributes:
        modelParser:
            :class:`~gametime.smt.parsers.modelParser.ModelParser` object that
            contains this
            :class:`~gametime.smt.parsers.boolectorModelParser.BoolectorArray`
            object.
        name:
            Name of the array.
        defaultValue:
            Default value of the array.
    """

    def __init__(self, modelParser, name="", defaultValue=0):
        super(BoolectorArray, self).__init__(modelParser, name, defaultValue)

    def get(self, indices, projectConfig):
        """Gets the value of the array at the indices specified.

        Argument:
            indices:
                Tuple of indices accessed in the array. For example, if
                this
                :class:`~gametime.smt.parsers.boolectorModelParser.BoolectorArray`
                object represents a two-dimensional array `a`, the value of
                `a[0][1]` can be obtained by calling this function with
                the tuple `(0, 1)`.
            projectConfig:
                :class:`~gametime.projectConfiguration.ProjectConfiguration`
                object that represents the configuration of a GameTime project.

        Returns:
            Value of the array at the indices specified.
        """
        indexBitsize = config.WORD_BITSIZE
        binaryIndices = ""
        for index in indices:
            binaryIndex = ModelParser.decToBin(index)[2:]
            binaryIndices += binaryIndex.zfill(indexBitsize)
        return self.outputs.get(binaryIndices, self.defaultOutput)


class BoolectorModelParser(ModelParser):
    """Parses the models generated by the Boolector SMT solver."""

    def __init__(self):
        super(BoolectorModelParser, self).__init__()

        #: :class:`~gametime.smt.parsers.boolectorModelLexer.BoolectorModelLexer`
        #: object that performs the lexical analysis of the models generated by
        #: the Boolector SMT solver.
        self.modelLexer = BoolectorModelLexer()

    ### PARSER GRAMMAR RULES ###
    def p_model(self, p):
        """model : assign
                 | assign model"""
        p[0] = None

    def p_var_name(self, p):
        """var_name : WORD"""
        p[0] = p[1]

    def p_temp_var(self, p):
        """temp_var : var_name LANGLE NUMBER RANGLE"""
        p[0] = p[1] + p[2] + p[3] + p[4]

    def p_index_var(self, p):
        """index_var : TEMPINDEX NUMBER"""
        p[0] = int(p[2])

    def p_efc_var(self, p):
        """efc_var : EFC var_name AT NUMBER"""
        p[0] = p[1] + p[2] + p[3] + p[4]

    def p_constraint_var(self, p):
        """constraint_var : CONSTRAINT NUMBER"""
        p[0] = None

    def p_assign_var(self, p):
        """assign : var_name NUMBER"""
        self.allAssignments[p[1]] = BoolectorModelParser.binToDec(p[2])
        p[0] = None

    def p_assign_temp_var(self, p):
        """assign : temp_var NUMBER"""
        self.allAssignments[p[1]] = BoolectorModelParser.binToDec(p[2])
        p[0] = None

    def p_assign_xvalue(self, p):
        """assign : var_name WORD
                  | temp_var WORD"""
        p[0] = None

    def p_assign_index_var(self, p):
        """assign : index_var NUMBER"""
        self.arrayTempIndexVals[p[1]] = BoolectorModelParser.binToDec(p[2])
        p[0] = None

    def p_assign_array(self, p):
        """assign : var_name LBRACKET NUMBER RBRACKET NUMBER
                  | temp_var LBRACKET NUMBER RBRACKET NUMBER"""
        boolectorArray = self.allMappings.get(p[1],
                                              BoolectorArray(self, name=p[1]))
        boolectorArray.add(p[3], BoolectorModelParser.binToDec(p[5]))
        self.allMappings[p[1]] = boolectorArray
        p[0] = None

    def p_assign_efc_var(self, p):
        """assign : efc_var NUMBER"""
        self.allAssignments[p[1]] = BoolectorModelParser.binToDec(p[2])
        p[0] = None

    def p_assign_constraint_var(self, p):
        """assign : constraint_var NUMBER"""
        p[0] = None
